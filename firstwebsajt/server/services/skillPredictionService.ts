/**\n * Skill Prediction Service\n * ML-based rank and skill prediction\n */\n\nimport db from '../database/connection';\nimport logger from '../utils/logger';\n\ninterface SkillMetrics {\n  winRate: number;\n  kda: number;\n  csPerMinute: number;\n  damagePerMinute: number;\n  goldPerMinute: number;\n  survivability: number;\n  consistency: number;\n}\n\ninterface RankPrediction {\n  currentRank: string;\n  predictedRank: string;\n  probability: number;\n  daysToRankUp: number;\n  requiredWinRate: number;\n  skillGap: number;\n}\n\nclass SkillPredictionService {\n  /**\n   * Calculate skill metrics\n   */\n  async calculateSkillMetrics(userId: string): Promise<SkillMetrics | null> {\n    try {\n      const result = await db.query(\n        `SELECT \n           SUM(CASE WHEN result = 'win' THEN 1 ELSE 0 END)::float / COUNT(*) as win_rate,\n           (AVG(kills) + AVG(assists)) / NULLIF(AVG(deaths), 0) as kda,\n           AVG(cs_per_minute) as cs_per_minute,\n           AVG(damage_dealt) / NULLIF(AVG(duration), 0) * 60 as damage_per_minute,\n           AVG(gold) / NULLIF(AVG(duration), 0) * 60 as gold_per_minute,\n           (100 - (COUNT(CASE WHEN deaths > 5 THEN 1 END)::float / COUNT(*) * 100)) as survivability,\n           (100 - (STDDEV(CASE WHEN result = 'win' THEN 1 ELSE 0 END)::float * 100)) as consistency\n         FROM matches\n         WHERE user_id = $1 AND match_timestamp > NOW() - INTERVAL '30 days'`,\n        [userId]\n      );\n\n      if (result.rows.length === 0) {\n        return null;\n      }\n\n      const data = result.rows[0];\n      return {\n        winRate: data.win_rate || 0,\n        kda: data.kda || 0,\n        csPerMinute: data.cs_per_minute || 0,\n        damagePerMinute: data.damage_per_minute || 0,\n        goldPerMinute: data.gold_per_minute || 0,\n        survivability: data.survivability || 50,\n        consistency: data.consistency || 50,\n      };\n    } catch (error) {\n      logger.error({ message: 'Failed to calculate skill metrics', error });\n      return null;\n    }\n  }\n\n  /**\n   * Predict next rank\n   */\n  async predictNextRank(userId: string): Promise<RankPrediction | null> {\n    try {\n      // Get current rank\n      const rankResult = await db.query(\n        'SELECT current_rank FROM player_accounts WHERE user_id = $1',\n        [userId]\n      );\n\n      if (rankResult.rows.length === 0) {\n        return null;\n      }\n\n      const currentRank = rankResult.rows[0].current_rank;\n\n      // Get skill metrics\n      const metrics = await this.calculateSkillMetrics(userId);\n      if (!metrics) {\n        return null;\n      }\n\n      // Rank progression\n      const rankProgression = [\n        'IRON',\n        'BRONZE',\n        'SILVER',\n        'GOLD',\n        'PLATINUM',\n        'EMERALD',\n        'DIAMOND',\n        'MASTER',\n        'GRANDMASTER',\n      ];\n\n      const currentRankIndex = rankProgression.indexOf(currentRank);\n      const nextRankIndex = Math.min(currentRankIndex + 1, rankProgression.length - 1);\n      const nextRank = rankProgression[nextRankIndex];\n\n      // Calculate probability based on metrics\n      const probability = this.calculateRankUpProbability(metrics, currentRank);\n\n      // Calculate required win rate\n      const requiredWinRate = this.calculateRequiredWinRate(metrics, currentRank);\n\n      // Calculate days to rank up\n      const daysToRankUp = this.calculateDaysToRankUp(metrics.winRate, requiredWinRate);\n\n      // Calculate skill gap\n      const skillGap = this.calculateSkillGap(metrics, currentRank);\n\n      return {\n        currentRank,\n        predictedRank: nextRank,\n        probability,\n        daysToRankUp,\n        requiredWinRate,\n        skillGap,\n      };\n    } catch (error) {\n      logger.error({ message: 'Failed to predict next rank', error });\n      return null;\n    }\n  }\n\n  /**\n   * Calculate rank up probability\n   */\n  private calculateRankUpProbability(metrics: SkillMetrics, currentRank: string): number {\n    // Weights for different metrics\n    const weights = {\n      winRate: 0.4,\n      kda: 0.2,\n      csPerMinute: 0.15,\n      damagePerMinute: 0.1,\n      survivability: 0.1,\n      consistency: 0.05,\n    };\n\n    // Normalize metrics to 0-100 scale\n    const normalizedMetrics = {\n      winRate: Math.min(metrics.winRate * 100, 100),\n      kda: Math.min(metrics.kda * 10, 100),\n      csPerMinute: Math.min(metrics.csPerMinute * 10, 100),\n      damagePerMinute: Math.min(metrics.damagePerMinute / 100, 100),\n      survivability: metrics.survivability,\n      consistency: metrics.consistency,\n    };\n\n    // Calculate weighted score\n    const score =\n      normalizedMetrics.winRate * weights.winRate +\n      normalizedMetrics.kda * weights.kda +\n      normalizedMetrics.csPerMinute * weights.csPerMinute +\n      normalizedMetrics.damagePerMinute * weights.damagePerMinute +\n      normalizedMetrics.survivability * weights.survivability +\n      normalizedMetrics.consistency * weights.consistency;\n\n    // Convert to probability (0-1)\n    return Math.min(score / 100, 1);\n  }\n\n  /**\n   * Calculate required win rate for rank up\n   */\n  private calculateRequiredWinRate(metrics: SkillMetrics, currentRank: string): number {\n    // Base required win rate by rank\n    const baseWinRates: { [key: string]: number } = {\n      IRON: 0.52,\n      BRONZE: 0.54,\n      SILVER: 0.55,\n      GOLD: 0.56,\n      PLATINUM: 0.57,\n      EMERALD: 0.58,\n      DIAMOND: 0.6,\n      MASTER: 0.62,\n      GRANDMASTER: 0.65,\n    };\n\n    const baseWinRate = baseWinRates[currentRank] || 0.55;\n\n    // Adjust based on KDA\n    const kdaAdjustment = Math.max(metrics.kda - 1, 0) * 0.02;\n\n    return Math.max(baseWinRate - kdaAdjustment, 0.5);\n  }\n\n  /**\n   * Calculate days to rank up\n   */\n  private calculateDaysToRankUp(currentWinRate: number, requiredWinRate: number): number {\n    if (currentWinRate >= requiredWinRate) {\n      return 1; // Already at required win rate\n    }\n\n    // Assume 5 matches per day\n    const matchesPerDay = 5;\n    const winRateDifference = requiredWinRate - currentWinRate;\n\n    // Calculate days needed\n    const daysNeeded = Math.ceil((winRateDifference * 100) / (matchesPerDay * 2));\n\n    return Math.max(daysNeeded, 1);\n  }\n\n  /**\n   * Calculate skill gap\n   */\n  private calculateSkillGap(metrics: SkillMetrics, currentRank: string): number {\n    // Target metrics for next rank\n    const targetMetrics: { [key: string]: SkillMetrics } = {\n      IRON: {\n        winRate: 0.52,\n        kda: 1.5,\n        csPerMinute: 4,\n        damagePerMinute: 300,\n        goldPerMinute: 200,\n        survivability: 70,\n        consistency: 60,\n      },\n      BRONZE: {\n        winRate: 0.54,\n        kda: 2,\n        csPerMinute: 5,\n        damagePerMinute: 350,\n        goldPerMinute: 250,\n        survivability: 75,\n        consistency: 65,\n      },\n      SILVER: {\n        winRate: 0.55,\n        kda: 2.5,\n        csPerMinute: 6,\n        damagePerMinute: 400,\n        goldPerMinute: 300,\n        survivability: 80,\n        consistency: 70,\n      },\n      // ... more ranks\n    };\n\n    const target = targetMetrics[currentRank] || targetMetrics['IRON'];\n\n    // Calculate gap as percentage\n    const gaps = [\n      Math.abs(metrics.winRate - target.winRate) / target.winRate,\n      Math.abs(metrics.kda - target.kda) / target.kda,\n      Math.abs(metrics.csPerMinute - target.csPerMinute) / target.csPerMinute,\n    ];\n\n    const averageGap = gaps.reduce((a, b) => a + b, 0) / gaps.length;\n\n    return Math.min(averageGap * 100, 100);\n  }\n\n  /**\n   * Get skill improvement suggestions\n   */\n  async getSkillImprovementSuggestions(userId: string): Promise<string[]> {\n    try {\n      const metrics = await this.calculateSkillMetrics(userId);\n      if (!metrics) {\n        return [];\n      }\n\n      const suggestions: string[] = [];\n\n      // Win rate suggestions\n      if (metrics.winRate < 0.5) {\n        suggestions.push('Focus on winning more games. Your win rate is below 50%.');\n      }\n\n      // KDA suggestions\n      if (metrics.kda < 1.5) {\n        suggestions.push('Improve your KDA. Focus on getting more kills and assists.');\n      }\n\n      // CS suggestions\n      if (metrics.csPerMinute < 5) {\n        suggestions.push('Improve your CS. Aim for 6+ CS per minute.');\n      }\n\n      // Damage suggestions\n      if (metrics.damagePerMinute < 300) {\n        suggestions.push('Increase your damage output. Be more aggressive in fights.');\n      }\n\n      // Survivability suggestions\n      if (metrics.survivability < 75) {\n        suggestions.push('Improve your survivability. Die less frequently.');\n      }\n\n      // Consistency suggestions\n      if (metrics.consistency < 60) {\n        suggestions.push('Improve your consistency. Play more stable games.');\n      }\n\n      return suggestions.length > 0 ? suggestions : ['You\\'re doing great! Keep improving!'];\n    } catch (error) {\n      logger.error({ message: 'Failed to get improvement suggestions', error });\n      return [];\n    }\n  }\n}\n\nexport default new SkillPredictionService();\n
