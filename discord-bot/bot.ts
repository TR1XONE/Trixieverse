/**\n * TrixieVerse Discord Bot\n * Community integration and notifications\n */\n\nimport { Client, GatewayIntentBits, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } from 'discord.js';\nimport logger from '../server/utils/logger.js';\nimport db from '../server/database/connection.js';\n\nconst client = new Client({\n  intents: [\n    GatewayIntentBits.Guilds,\n    GatewayIntentBits.GuildMessages,\n    GatewayIntentBits.DirectMessages,\n    GatewayIntentBits.MessageContent,\n  ],\n});\n\nconst TOKEN = process.env.DISCORD_BOT_TOKEN || '';\nconst GUILD_ID = process.env.DISCORD_GUILD_ID || '';\nconst NOTIFICATIONS_CHANNEL = process.env.DISCORD_NOTIFICATIONS_CHANNEL || '';\nconst LEADERBOARD_CHANNEL = process.env.DISCORD_LEADERBOARD_CHANNEL || '';\n\n// Bot ready\nclient.on('ready', () => {\n  logger.info(`Discord bot logged in as ${client.user?.tag}`);\n  client.user?.setActivity('Wild Rift coaching', { type: 'PLAYING' });\n});\n\n// Message handler\nclient.on('messageCreate', async (message) => {\n  if (message.author.bot) return;\n\n  try {\n    if (message.content.startsWith('!rank')) {\n      await handleRankCommand(message);\n    } else if (message.content.startsWith('!stats')) {\n      await handleStatsCommand(message);\n    } else if (message.content.startsWith('!leaderboard')) {\n      await handleLeaderboardCommand(message);\n    } else if (message.content.startsWith('!help')) {\n      await handleHelpCommand(message);\n    }\n  } catch (error) {\n    logger.error({ message: 'Discord bot error', error });\n  }\n});\n\n/**\n * Handle !rank command\n */\nasync function handleRankCommand(message: any) {\n  const args = message.content.split(' ');\n  const username = args.slice(1).join(' ');\n\n  if (!username) {\n    return message.reply('Usage: `!rank <username>`');\n  }\n\n  try {\n    const result = await db.query(\n      'SELECT * FROM users WHERE username = $1',\n      [username]\n    );\n\n    if (result.rows.length === 0) {\n      return message.reply(`User \"${username}\" not found.`);\n    }\n\n    const user = result.rows[0];\n    const leaderboard = await db.query(\n      'SELECT * FROM leaderboard_entries WHERE user_id = $1',\n      [user.id]\n    );\n\n    const embed = new EmbedBuilder()\n      .setColor('#0ea5e9')\n      .setTitle(`ğŸ“Š ${username}'s Stats`)\n      .addFields(\n        { name: 'Level', value: `${leaderboard.rows[0]?.level || 1}`, inline: true },\n        { name: 'XP', value: `${leaderboard.rows[0]?.xp || 0}`, inline: true },\n        { name: 'Win Rate', value: `${leaderboard.rows[0]?.win_rate || 0}%`, inline: true },\n        { name: 'Matches Played', value: `${leaderboard.rows[0]?.matches_played || 0}`, inline: true }\n      )\n      .setTimestamp();\n\n    await message.reply({ embeds: [embed] });\n  } catch (error) {\n    logger.error({ message: 'Failed to handle rank command', error });\n    await message.reply('Error fetching stats.');\n  }\n}\n\n/**\n * Handle !stats command\n */\nasync function handleStatsCommand(message: any) {\n  try {\n    const result = await db.query(\n      `SELECT u.username, l.level, l.xp, l.win_rate\n       FROM leaderboard_entries l\n       JOIN users u ON l.user_id = u.id\n       ORDER BY l.xp DESC\n       LIMIT 10`\n    );\n\n    const statsText = result.rows\n      .map(\n        (row, idx) =>\n          `${idx + 1}. **${row.username}** - Level ${row.level} (${row.xp} XP) - ${row.win_rate}% WR`\n      )\n      .join('\\n');\n\n    const embed = new EmbedBuilder()\n      .setColor('#0ea5e9')\n      .setTitle('ğŸ† Top 10 Players')\n      .setDescription(statsText)\n      .setTimestamp();\n\n    await message.reply({ embeds: [embed] });\n  } catch (error) {\n    logger.error({ message: 'Failed to handle stats command', error });\n    await message.reply('Error fetching leaderboard.');\n  }\n}\n\n/**\n * Handle !leaderboard command\n */\nasync function handleLeaderboardCommand(message: any) {\n  try {\n    const result = await db.query(\n      `SELECT u.username, l.level, l.xp, l.win_rate\n       FROM leaderboard_entries l\n       JOIN users u ON l.user_id = u.id\n       ORDER BY l.xp DESC\n       LIMIT 5`\n    );\n\n    const leaderboardText = result.rows\n      .map(\n        (row, idx) =>\n          `${['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰', '4ï¸âƒ£', '5ï¸âƒ£'][idx]} ${row.username} - Level ${row.level} (${row.xp} XP)`\n      )\n      .join('\\n');\n\n    const embed = new EmbedBuilder()\n      .setColor('#0ea5e9')\n      .setTitle('ğŸ† TrixieVerse Leaderboard')\n      .setDescription(leaderboardText)\n      .setFooter({ text: 'Updated every hour' })\n      .setTimestamp();\n\n    await message.reply({ embeds: [embed] });\n  } catch (error) {\n    logger.error({ message: 'Failed to handle leaderboard command', error });\n    await message.reply('Error fetching leaderboard.');\n  }\n}\n\n/**\n * Handle !help command\n */\nasync function handleHelpCommand(message: any) {\n  const embed = new EmbedBuilder()\n    .setColor('#0ea5e9')\n    .setTitle('ğŸ“– TrixieVerse Bot Commands')\n    .addFields(\n      { name: '!rank <username>', value: 'Get player stats' },\n      { name: '!stats', value: 'View top 10 players' },\n      { name: '!leaderboard', value: 'View top 5 players' },\n      { name: '!help', value: 'Show this help message' }\n    )\n    .setTimestamp();\n\n  await message.reply({ embeds: [embed] });\n}\n\n/**\n * Send achievement notification to Discord\n */\nexport async function notifyAchievementDiscord(\n  userId: string,\n  achievement: { title: string; description: string; icon: string }\n) {\n  try {\n    const channel = client.channels.cache.get(NOTIFICATIONS_CHANNEL);\n    if (!channel || !channel.isTextBased()) return;\n\n    const user = await db.query('SELECT username FROM users WHERE id = $1', [userId]);\n    if (user.rows.length === 0) return;\n\n    const embed = new EmbedBuilder()\n      .setColor('#0ea5e9')\n      .setTitle(`${achievement.icon} Achievement Unlocked!`)\n      .addFields(\n        { name: 'Player', value: user.rows[0].username },\n        { name: 'Achievement', value: achievement.title },\n        { name: 'Description', value: achievement.description }\n      )\n      .setTimestamp();\n\n    await channel.send({ embeds: [embed] });\n  } catch (error) {\n    logger.error({ message: 'Failed to send achievement notification', error });\n  }\n}\n\n/**\n * Send rank up notification to Discord\n */\nexport async function notifyRankUpDiscord(userId: string, newRank: string) {\n  try {\n    const channel = client.channels.cache.get(NOTIFICATIONS_CHANNEL);\n    if (!channel || !channel.isTextBased()) return;\n\n    const user = await db.query('SELECT username FROM users WHERE id = $1', [userId]);\n    if (user.rows.length === 0) return;\n\n    const embed = new EmbedBuilder()\n      .setColor('#fbbf24')\n      .setTitle('ğŸ“ˆ Rank Up!')\n      .addFields(\n        { name: 'Player', value: user.rows[0].username },\n        { name: 'New Rank', value: newRank }\n      )\n      .setTimestamp();\n\n    await channel.send({ embeds: [embed] });\n  } catch (error) {\n    logger.error({ message: 'Failed to send rank up notification', error });\n  }\n}\n\n/**\n * Update leaderboard in Discord\n */\nexport async function updateLeaderboardDiscord() {\n  try {\n    const channel = client.channels.cache.get(LEADERBOARD_CHANNEL);\n    if (!channel || !channel.isTextBased()) return;\n\n    const result = await db.query(\n      `SELECT u.username, l.level, l.xp, l.win_rate\n       FROM leaderboard_entries l\n       JOIN users u ON l.user_id = u.id\n       ORDER BY l.xp DESC\n       LIMIT 10`\n    );\n\n    const leaderboardText = result.rows\n      .map(\n        (row, idx) =>\n          `${idx + 1}. **${row.username}** - Level ${row.level} (${row.xp} XP) - ${row.win_rate}% WR`\n      )\n      .join('\\n');\n\n    const embed = new EmbedBuilder()\n      .setColor('#0ea5e9')\n      .setTitle('ğŸ† TrixieVerse Leaderboard')\n      .setDescription(leaderboardText)\n      .setFooter({ text: 'Updated hourly' })\n      .setTimestamp();\n\n    // Delete old message and send new one\n    const messages = await channel.messages.fetch({ limit: 1 });\n    if (messages.size > 0) {\n      await messages.first()?.delete();\n    }\n\n    await channel.send({ embeds: [embed] });\n  } catch (error) {\n    logger.error({ message: 'Failed to update leaderboard', error });\n  }\n}\n\n// Login\nclient.login(TOKEN);\n\nexport default client;\n
