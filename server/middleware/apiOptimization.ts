/**\n * API Optimization Middleware\n * Response compression, pagination, field filtering\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport compression from 'compression';\nimport logger from '../utils/logger';\n\n/**\n * Compression middleware with custom settings\n */\nexport const compressionMiddleware = compression({\n  level: 6, // Balance between compression ratio and CPU usage\n  threshold: 1024, // Only compress responses larger than 1KB\n  filter: (req, res) => {\n    // Don't compress if request has 'no-transform' header\n    if (req.headers['cache-control']?.includes('no-transform')) {\n      return false;\n    }\n    // Use compression filter function\n    return compression.filter(req, res);\n  },\n});\n\n/**\n * Pagination middleware\n */\nexport const paginationMiddleware = (req: Request, res: Response, next: NextFunction) => {\n  const page = Math.max(1, parseInt(req.query.page as string) || 1);\n  const limit = Math.min(100, parseInt(req.query.limit as string) || 20); // Max 100 items per page\n  const offset = (page - 1) * limit;\n\n  (req as any).pagination = {\n    page,\n    limit,\n    offset,\n  };\n\n  next();\n};\n\n/**\n * Field filtering middleware\n * Allows clients to request only specific fields\n */\nexport const fieldFilterMiddleware = (req: Request, res: Response, next: NextFunction) => {\n  const fields = req.query.fields as string;\n  if (fields) {\n    (req as any).selectedFields = fields.split(',').map((f) => f.trim());\n  }\n  next();\n};\n\n/**\n * Response optimization middleware\n * Removes unnecessary fields, minifies responses\n */\nexport const responseOptimizationMiddleware = (req: Request, res: Response, next: NextFunction) => {\n  const originalJson = res.json.bind(res);\n\n  res.json = function (data: any) {\n    // Apply field filtering if requested\n    if ((req as any).selectedFields) {\n      data = filterFields(data, (req as any).selectedFields);\n    }\n\n    // Add pagination metadata if available\n    if ((req as any).pagination) {\n      res.set('X-Pagination-Page', (req as any).pagination.page.toString());\n      res.set('X-Pagination-Limit', (req as any).pagination.limit.toString());\n    }\n\n    // Call original json method\n    return originalJson(data);\n  };\n\n  next();\n};\n\n/**\n * Filter object fields\n */\nfunction filterFields(data: any, fields: string[]): any {\n  if (Array.isArray(data)) {\n    return data.map((item) => filterFields(item, fields));\n  }\n\n  if (typeof data === 'object' && data !== null) {\n    const filtered: any = {};\n    for (const field of fields) {\n      if (field in data) {\n        filtered[field] = data[field];\n      }\n    }\n    return filtered;\n  }\n\n  return data;\n}\n\n/**\n * Query optimization middleware\n * Prevents N+1 queries by enforcing eager loading\n */\nexport const queryOptimizationMiddleware = (req: Request, res: Response, next: NextFunction) => {\n  const include = req.query.include as string;\n  if (include) {\n    (req as any).eagerLoad = include.split(',').map((i) => i.trim());\n  }\n  next();\n};\n\n/**\n * Response caching middleware\n * Caches GET requests with ETags\n */\nexport const responseCachingMiddleware = (req: Request, res: Response, next: NextFunction) => {\n  if (req.method !== 'GET') {\n    return next();\n  }\n\n  const originalJson = res.json.bind(res);\n\n  res.json = function (data: any) {\n    // Generate ETag\n    const crypto = require('crypto');\n    const hash = crypto.createHash('md5').update(JSON.stringify(data)).digest('hex');\n    const etag = `\"${hash}\"`;\n\n    res.set('ETag', etag);\n    res.set('Cache-Control', 'public, max-age=300'); // 5 minutes\n\n    // Check If-None-Match header\n    if (req.get('If-None-Match') === etag) {\n      res.status(304).end();\n      return res;\n    }\n\n    return originalJson(data);\n  };\n\n  next();\n};\n\n/**\n * Batch request middleware\n * Allows clients to batch multiple requests\n */\nexport const batchRequestMiddleware = (req: Request, res: Response, next: NextFunction) => {\n  if (req.path === '/api/batch' && req.method === 'POST') {\n    const requests = req.body.requests as Array<{ method: string; path: string; body?: any }>;\n\n    if (!Array.isArray(requests) || requests.length === 0) {\n      return res.status(400).json({ error: 'Invalid batch request' });\n    }\n\n    if (requests.length > 50) {\n      return res.status(400).json({ error: 'Maximum 50 requests per batch' });\n    }\n\n    (req as any).batchRequests = requests;\n  }\n\n  next();\n};\n\n/**\n * Response streaming for large datasets\n */\nexport const streamingMiddleware = (req: Request, res: Response, next: NextFunction) => {\n  if (req.query.stream === 'true') {\n    res.setHeader('Content-Type', 'application/x-ndjson');\n    (req as any).streaming = true;\n  }\n  next();\n};\n\n/**\n * Gzip streaming for large responses\n */\nexport const gzipStreamingMiddleware = (req: Request, res: Response, next: NextFunction) => {\n  if (req.accepts('gzip') && (req as any).streaming) {\n    res.setHeader('Content-Encoding', 'gzip');\n  }\n  next();\n};\n\n/**\n * API versioning middleware\n */\nexport const apiVersioningMiddleware = (req: Request, res: Response, next: NextFunction) => {\n  const version = req.get('API-Version') || req.query.version || 'v1';\n  (req as any).apiVersion = version;\n  res.set('API-Version', version);\n  next();\n};\n\n/**\n * Response time tracking\n */\nexport const responseTimeMiddleware = (req: Request, res: Response, next: NextFunction) => {\n  const startTime = Date.now();\n\n  res.on('finish', () => {\n    const duration = Date.now() - startTime;\n    res.set('X-Response-Time', `${duration}ms`);\n\n    // Log slow responses\n    if (duration > 1000) {\n      logger.warn({\n        message: 'Slow API response',\n        method: req.method,\n        path: req.path,\n        duration,\n        statusCode: res.statusCode,\n      });\n    }\n  });\n\n  next();\n};\n\n/**\n * Partial response support (GraphQL-like field selection)\n */\nexport const partialResponseMiddleware = (req: Request, res: Response, next: NextFunction) => {\n  const select = req.query.select as string;\n  if (select) {\n    (req as any).selectFields = select.split(',').map((f) => f.trim());\n  }\n  next();\n};\n\n/**\n * Sorting middleware\n */\nexport const sortingMiddleware = (req: Request, res: Response, next: NextFunction) => {\n  const sort = req.query.sort as string;\n  if (sort) {\n    const sortFields = sort.split(',').map((s) => {\n      const field = s.startsWith('-') ? s.substring(1) : s;\n      const direction = s.startsWith('-') ? 'DESC' : 'ASC';\n      return { field, direction };\n    });\n    (req as any).sortFields = sortFields;\n  }\n  next();\n};\n\n/**\n * Filtering middleware\n */\nexport const filteringMiddleware = (req: Request, res: Response, next: NextFunction) => {\n  const filter = req.query.filter as string;\n  if (filter) {\n    try {\n      (req as any).filters = JSON.parse(filter);\n    } catch (error) {\n      return res.status(400).json({ error: 'Invalid filter format' });\n    }\n  }\n  next();\n};\n\n/**\n * Search middleware\n */\nexport const searchMiddleware = (req: Request, res: Response, next: NextFunction) => {\n  const q = req.query.q as string;\n  if (q) {\n    // Sanitize search query\n    (req as any).searchQuery = q.replace(/[^a-zA-Z0-9\\s-]/g, '').trim();\n  }\n  next();\n};\n\n/**\n * Combine all optimization middlewares\n */\nexport const apiOptimizationStack = [\n  compressionMiddleware,\n  paginationMiddleware,\n  fieldFilterMiddleware,\n  responseOptimizationMiddleware,\n  queryOptimizationMiddleware,\n  responseCachingMiddleware,\n  apiVersioningMiddleware,\n  responseTimeMiddleware,\n  partialResponseMiddleware,\n  sortingMiddleware,\n  filteringMiddleware,\n  searchMiddleware,\n];\n
