/**\n * Advanced Rate Limiting Middleware\n * Sophisticated rate limiting with different tiers\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport redis from 'redis';\nimport logger from '../utils/logger.js';\n\nconst client = redis.createClient({\n  host: process.env.REDIS_HOST || 'localhost',\n  port: parseInt(process.env.REDIS_PORT || '6379'),\n});\n\ninterface RateLimitConfig {\n  windowMs: number; // Time window in ms\n  maxRequests: number; // Max requests per window\n  message: string;\n  statusCode: number;\n  skipSuccessfulRequests?: boolean;\n  skipFailedRequests?: boolean;\n}\n\ninterface UserRateLimitTier {\n  tier: 'free' | 'premium' | 'pro';\n  requestsPerMinute: number;\n  requestsPerHour: number;\n  requestsPerDay: number;\n  burstLimit: number; // Max requests in 10 seconds\n}\n\nclass AdvancedRateLimiter {\n  private userTiers: Map<string, UserRateLimitTier> = new Map();\n\n  constructor() {\n    this.initializeUserTiers();\n  }\n\n  /**\n   * Initialize user tier limits\n   */\n  private initializeUserTiers() {\n    this.userTiers.set('free', {\n      tier: 'free',\n      requestsPerMinute: 30,\n      requestsPerHour: 500,\n      requestsPerDay: 5000,\n      burstLimit: 5,\n    });\n\n    this.userTiers.set('premium', {\n      tier: 'premium',\n      requestsPerMinute: 100,\n      requestsPerHour: 2000,\n      requestsPerDay: 20000,\n      burstLimit: 20,\n    });\n\n    this.userTiers.set('pro', {\n      tier: 'pro',\n      requestsPerMinute: 300,\n      requestsPerHour: 5000,\n      requestsPerDay: 50000,\n      burstLimit: 50,\n    });\n  }\n\n  /**\n   * Create rate limiter middleware\n   */\n  createLimiter(config: RateLimitConfig) {\n    return async (req: Request, res: Response, next: NextFunction) => {\n      const identifier = this.getIdentifier(req);\n      const key = `ratelimit:${identifier}`;\n\n      try {\n        // Get current request count\n        const count = await client.incr(key);\n\n        // Set expiration on first request\n        if (count === 1) {\n          await client.expire(key, Math.ceil(config.windowMs / 1000));\n        }\n\n        // Check if limit exceeded\n        if (count > config.maxRequests) {\n          res.status(config.statusCode).json({\n            error: config.message,\n            retryAfter: Math.ceil(config.windowMs / 1000),\n          });\n          return;\n        }\n\n        // Add headers\n        res.set('X-RateLimit-Limit', config.maxRequests.toString());\n        res.set('X-RateLimit-Remaining', (config.maxRequests - count).toString());\n        res.set('X-RateLimit-Reset', new Date(Date.now() + config.windowMs).toISOString());\n\n        next();\n      } catch (error) {\n        logger.error({ message: 'Rate limiter error', error });\n        next(); // Allow request if rate limiter fails\n      }\n    };\n  }\n\n  /**\n   * Create user-tier rate limiter\n   */\n  createUserTierLimiter() {\n    return async (req: Request, res: Response, next: NextFunction) => {\n      const userId = (req as any).user?.id;\n      if (!userId) {\n        return next();\n      }\n\n      try {\n        // Get user tier (from database or cache)\n        const userTier = await this.getUserTier(userId);\n        const limits = this.userTiers.get(userTier) || this.userTiers.get('free')!;\n\n        // Check minute limit\n        const minuteKey = `ratelimit:user:${userId}:minute`;\n        const minuteCount = await client.incr(minuteKey);\n        if (minuteCount === 1) {\n          await client.expire(minuteKey, 60);\n        }\n\n        if (minuteCount > limits.requestsPerMinute) {\n          res.status(429).json({\n            error: 'Too many requests. Please try again later.',\n            retryAfter: 60,\n          });\n          return;\n        }\n\n        // Check burst limit (10 seconds)\n        const burstKey = `ratelimit:user:${userId}:burst`;\n        const burstCount = await client.incr(burstKey);\n        if (burstCount === 1) {\n          await client.expire(burstKey, 10);\n        }\n\n        if (burstCount > limits.burstLimit) {\n          res.status(429).json({\n            error: 'Too many requests. Burst limit exceeded.',\n            retryAfter: 10,\n          });\n          return;\n        }\n\n        // Add headers\n        res.set('X-RateLimit-Tier', userTier);\n        res.set('X-RateLimit-Requests-Remaining', (limits.requestsPerMinute - minuteCount).toString());\n\n        next();\n      } catch (error) {\n        logger.error({ message: 'User tier rate limiter error', error });\n        next();\n      }\n    };\n  }\n\n  /**\n   * Create endpoint-specific rate limiter\n   */\n  createEndpointLimiter(endpoint: string) {\n    const limits: { [key: string]: RateLimitConfig } = {\n      '/api/auth/login': {\n        windowMs: 15 * 60 * 1000, // 15 minutes\n        maxRequests: 5,\n        message: 'Too many login attempts. Please try again later.',\n        statusCode: 429,\n      },\n      '/api/auth/register': {\n        windowMs: 60 * 60 * 1000, // 1 hour\n        maxRequests: 3,\n        message: 'Too many registration attempts. Please try again later.',\n        statusCode: 429,\n      },\n      '/api/matches/analyze': {\n        windowMs: 60 * 1000, // 1 minute\n        maxRequests: 10,\n        message: 'Too many analysis requests. Please try again later.',\n        statusCode: 429,\n      },\n      '/api/coach/response': {\n        windowMs: 10 * 1000, // 10 seconds\n        maxRequests: 5,\n        message: 'Too many coach requests. Please wait before asking again.',\n        statusCode: 429,\n      },\n    };\n\n    const config = limits[endpoint] || limits['/api/matches/analyze'];\n    return this.createLimiter(config);\n  }\n\n  /**\n   * Get request identifier (IP or user ID)\n   */\n  private getIdentifier(req: Request): string {\n    const userId = (req as any).user?.id;\n    if (userId) {\n      return `user:${userId}`;\n    }\n\n    const ip = req.ip || req.socket.remoteAddress || 'unknown';\n    return `ip:${ip}`;\n  }\n\n  /**\n   * Get user tier\n   */\n  private async getUserTier(userId: string): Promise<string> {\n    try {\n      // Check cache first\n      const cached = await client.get(`user:tier:${userId}`);\n      if (cached) {\n        return cached;\n      }\n\n      // Get from database (simplified)\n      // In production, query actual database\n      const tier = 'free'; // Default to free\n\n      // Cache for 1 hour\n      await client.setex(`user:tier:${userId}`, 3600, tier);\n\n      return tier;\n    } catch (error) {\n      logger.error({ message: 'Failed to get user tier', error });\n      return 'free';\n    }\n  }\n\n  /**\n   * Get rate limit status\n   */\n  async getRateLimitStatus(userId: string): Promise<any> {\n    try {\n      const userTier = await this.getUserTier(userId);\n      const limits = this.userTiers.get(userTier) || this.userTiers.get('free')!;\n\n      const minuteKey = `ratelimit:user:${userId}:minute`;\n      const minuteCount = await client.get(minuteKey);\n      const minuteTTL = await client.ttl(minuteKey);\n\n      const burstKey = `ratelimit:user:${userId}:burst`;\n      const burstCount = await client.get(burstKey);\n      const burstTTL = await client.ttl(burstKey);\n\n      return {\n        tier: userTier,\n        limits,\n        currentUsage: {\n          minute: parseInt(minuteCount || '0'),\n          burst: parseInt(burstCount || '0'),\n        },\n        remaining: {\n          minute: Math.max(limits.requestsPerMinute - parseInt(minuteCount || '0'), 0),\n          burst: Math.max(limits.burstLimit - parseInt(burstCount || '0'), 0),\n        },\n        resetIn: {\n          minute: Math.max(minuteTTL, 0),\n          burst: Math.max(burstTTL, 0),\n        },\n      };\n    } catch (error) {\n      logger.error({ message: 'Failed to get rate limit status', error });\n      return null;\n    }\n  }\n}\n\nexport default new AdvancedRateLimiter();\n
