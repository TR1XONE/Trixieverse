/**\n * Cache Middleware\n * HTTP caching for GET requests\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport cache from '../utils/cache.js';\n\ninterface CachedRequest extends Request {\n  cacheKey?: string;\n}\n\n/**\n * Cache middleware for GET requests\n */\nexport function cacheMiddleware(ttlSeconds: number = 300) {\n  return (req: CachedRequest, res: Response, next: NextFunction) => {\n    // Only cache GET requests\n    if (req.method !== 'GET') {\n      return next();\n    }\n\n    // Generate cache key\n    const cacheKey = `${req.user?.id}:${req.path}:${JSON.stringify(req.query)}`;\n    req.cacheKey = cacheKey;\n\n    // Check cache\n    const cachedData = cache.get(cacheKey);\n    if (cachedData) {\n      return res.json(cachedData);\n    }\n\n    // Override res.json to cache response\n    const originalJson = res.json.bind(res);\n    res.json = function (data: any) {\n      // Cache successful responses\n      if (res.statusCode === 200) {\n        cache.set(cacheKey, data, ttlSeconds);\n      }\n      return originalJson(data);\n    };\n\n    next();\n  };\n}\n\n/**\n * Invalidate cache\n */\nexport function invalidateCache(pattern?: string): void {\n  if (!pattern) {\n    cache.clear();\n    return;\n  }\n\n  // Invalidate specific cache entries matching pattern\n  const stats = cache.stats();\n  stats.entries.forEach((entry) => {\n    if (entry.key.includes(pattern)) {\n      cache.delete(entry.key);\n    }\n  });\n}\n\n/**\n * Cache invalidation middleware\n * Invalidates cache on POST/PUT/DELETE requests\n */\nexport function cacheInvalidationMiddleware(req: Request, res: Response, next: NextFunction) {\n  // Invalidate cache on mutations\n  if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(req.method)) {\n    // Invalidate user-specific cache\n    if (req.user?.id) {\n      invalidateCache(req.user.id);\n    }\n  }\n\n  next();\n}\n
