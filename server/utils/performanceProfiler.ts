/**\n * Performance Profiler & Monitoring\n * Track and optimize application performance\n */\n\nimport logger from './logger.js';\n\ninterface PerformanceMetric {\n  name: string;\n  duration: number; // ms\n  timestamp: Date;\n  tags?: { [key: string]: string };\n}\n\ninterface PerformanceStats {\n  name: string;\n  count: number;\n  totalDuration: number;\n  averageDuration: number;\n  minDuration: number;\n  maxDuration: number;\n  p50: number;\n  p95: number;\n  p99: number;\n}\n\nclass PerformanceProfiler {\n  private metrics: Map<string, PerformanceMetric[]> = new Map();\n  private activeTimers: Map<string, number> = new Map();\n  private maxMetricsPerName = 1000; // Keep last 1000 metrics per name\n\n  /**\n   * Start performance timer\n   */\n  startTimer(name: string): string {\n    const timerId = `${name}:${Date.now()}:${Math.random()}`;\n    this.activeTimers.set(timerId, Date.now());\n    return timerId;\n  }\n\n  /**\n   * End performance timer\n   */\n  endTimer(timerId: string, tags?: { [key: string]: string }): PerformanceMetric | null {\n    const startTime = this.activeTimers.get(timerId);\n    if (!startTime) {\n      logger.warn(`Timer not found: ${timerId}`);\n      return null;\n    }\n\n    const duration = Date.now() - startTime;\n    this.activeTimers.delete(timerId);\n\n    // Extract metric name from timer ID\n    const name = timerId.split(':')[0];\n\n    const metric: PerformanceMetric = {\n      name,\n      duration,\n      timestamp: new Date(),\n      tags,\n    };\n\n    // Store metric\n    if (!this.metrics.has(name)) {\n      this.metrics.set(name, []);\n    }\n\n    const metricsList = this.metrics.get(name)!;\n    metricsList.push(metric);\n\n    // Keep only last N metrics\n    if (metricsList.length > this.maxMetricsPerName) {\n      metricsList.shift();\n    }\n\n    // Log slow operations\n    if (duration > 1000) {\n      logger.warn({\n        message: `Slow operation detected: ${name}`,\n        duration,\n        tags,\n      });\n    }\n\n    return metric;\n  }\n\n  /**\n   * Measure function execution\n   */\n  async measureAsync<T>(\n    name: string,\n    fn: () => Promise<T>,\n    tags?: { [key: string]: string }\n  ): Promise<T> {\n    const timerId = this.startTimer(name);\n    try {\n      const result = await fn();\n      this.endTimer(timerId, tags);\n      return result;\n    } catch (error) {\n      this.endTimer(timerId, { ...tags, error: 'true' });\n      throw error;\n    }\n  }\n\n  /**\n   * Measure synchronous function execution\n   */\n  measureSync<T>(name: string, fn: () => T, tags?: { [key: string]: string }): T {\n    const timerId = this.startTimer(name);\n    try {\n      const result = fn();\n      this.endTimer(timerId, tags);\n      return result;\n    } catch (error) {\n      this.endTimer(timerId, { ...tags, error: 'true' });\n      throw error;\n    }\n  }\n\n  /**\n   * Get performance statistics\n   */\n  getStats(name: string): PerformanceStats | null {\n    const metrics = this.metrics.get(name);\n    if (!metrics || metrics.length === 0) {\n      return null;\n    }\n\n    const durations = metrics.map((m) => m.duration).sort((a, b) => a - b);\n    const totalDuration = durations.reduce((a, b) => a + b, 0);\n\n    return {\n      name,\n      count: metrics.length,\n      totalDuration,\n      averageDuration: totalDuration / metrics.length,\n      minDuration: durations[0],\n      maxDuration: durations[durations.length - 1],\n      p50: durations[Math.floor(durations.length * 0.5)],\n      p95: durations[Math.floor(durations.length * 0.95)],\n      p99: durations[Math.floor(durations.length * 0.99)],\n    };\n  }\n\n  /**\n   * Get all statistics\n   */\n  getAllStats(): PerformanceStats[] {\n    const stats: PerformanceStats[] = [];\n\n    for (const name of this.metrics.keys()) {\n      const stat = this.getStats(name);\n      if (stat) {\n        stats.push(stat);\n      }\n    }\n\n    return stats.sort((a, b) => b.totalDuration - a.totalDuration);\n  }\n\n  /**\n   * Get slow operations\n   */\n  getSlowOperations(threshold: number = 1000): PerformanceMetric[] {\n    const slowOps: PerformanceMetric[] = [];\n\n    for (const metrics of this.metrics.values()) {\n      for (const metric of metrics) {\n        if (metric.duration > threshold) {\n          slowOps.push(metric);\n        }\n      }\n    }\n\n    return slowOps.sort((a, b) => b.duration - a.duration);\n  }\n\n  /**\n   * Get memory usage\n   */\n  getMemoryUsage(): NodeJS.MemoryUsage {\n    return process.memoryUsage();\n  }\n\n  /**\n   * Get CPU usage\n   */\n  getCPUUsage(): NodeJS.CpuUsage {\n    return process.cpuUsage();\n  }\n\n  /**\n   * Generate performance report\n   */\n  generateReport(): string {\n    const stats = this.getAllStats();\n    const memory = this.getMemoryUsage();\n    const cpu = this.getCPUUsage();\n\n    let report = '\\n=== PERFORMANCE REPORT ===\\n\\n';\n\n    // Memory\n    report += 'Memory Usage:\\n';\n    report += `  Heap Used: ${(memory.heapUsed / 1024 / 1024).toFixed(2)} MB\\n`;\n    report += `  Heap Total: ${(memory.heapTotal / 1024 / 1024).toFixed(2)} MB\\n`;\n    report += `  External: ${(memory.external / 1024 / 1024).toFixed(2)} MB\\n\\n`;\n\n    // CPU\n    report += 'CPU Usage:\\n';\n    report += `  User: ${(cpu.user / 1000).toFixed(2)} ms\\n`;\n    report += `  System: ${(cpu.system / 1000).toFixed(2)} ms\\n\\n`;\n\n    // Top operations\n    report += 'Top 10 Operations by Total Duration:\\n';\n    for (let i = 0; i < Math.min(10, stats.length); i++) {\n      const stat = stats[i];\n      report += `  ${i + 1}. ${stat.name}\\n`;\n      report += `     Count: ${stat.count}\\n`;\n      report += `     Total: ${stat.totalDuration.toFixed(2)} ms\\n`;\n      report += `     Avg: ${stat.averageDuration.toFixed(2)} ms\\n`;\n      report += `     Min/Max: ${stat.minDuration.toFixed(2)}/${stat.maxDuration.toFixed(2)} ms\\n`;\n      report += `     P95/P99: ${stat.p95.toFixed(2)}/${stat.p99.toFixed(2)} ms\\n\\n`;\n    }\n\n    // Slow operations\n    const slowOps = this.getSlowOperations();\n    if (slowOps.length > 0) {\n      report += `\\nSlow Operations (>1000ms): ${slowOps.length}\\n`;\n      for (let i = 0; i < Math.min(5, slowOps.length); i++) {\n        const op = slowOps[i];\n        report += `  ${i + 1}. ${op.name}: ${op.duration.toFixed(2)} ms\\n`;\n      }\n    }\n\n    report += '\\n=========================\\n';\n    return report;\n  }\n\n  /**\n   * Clear metrics\n   */\n  clear(): void {\n    this.metrics.clear();\n    this.activeTimers.clear();\n  }\n\n  /**\n   * Clear specific metric\n   */\n  clearMetric(name: string): void {\n    this.metrics.delete(name);\n  }\n}\n\nexport default new PerformanceProfiler();\n
