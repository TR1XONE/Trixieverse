/**\n * Performance Monitoring\n * Track and analyze application performance\n */\n\ninterface PerformanceMetric {\n  name: string;\n  duration: number;\n  timestamp: number;\n}\n\nclass PerformanceMonitor {\n  private metrics: PerformanceMetric[] = [];\n  private maxMetrics: number = 10000;\n\n  /**\n   * Start performance measurement\n   */\n  start(name: string): () => void {\n    const startTime = Date.now();\n\n    return () => {\n      const duration = Date.now() - startTime;\n      this.recordMetric(name, duration);\n    };\n  }\n\n  /**\n   * Record metric\n   */\n  private recordMetric(name: string, duration: number): void {\n    this.metrics.push({\n      name,\n      duration,\n      timestamp: Date.now(),\n    });\n\n    // Keep only recent metrics\n    if (this.metrics.length > this.maxMetrics) {\n      this.metrics = this.metrics.slice(-this.maxMetrics);\n    }\n  }\n\n  /**\n   * Get metrics summary\n   */\n  getSummary(name?: string) {\n    const filtered = name\n      ? this.metrics.filter((m) => m.name === name)\n      : this.metrics;\n\n    if (filtered.length === 0) {\n      return null;\n    }\n\n    const durations = filtered.map((m) => m.duration);\n    const sum = durations.reduce((a, b) => a + b, 0);\n    const avg = sum / durations.length;\n    const min = Math.min(...durations);\n    const max = Math.max(...durations);\n    const p95 = this.percentile(durations, 95);\n    const p99 = this.percentile(durations, 99);\n\n    return {\n      count: filtered.length,\n      avg: Math.round(avg),\n      min,\n      max,\n      p95: Math.round(p95),\n      p99: Math.round(p99),\n    };\n  }\n\n  /**\n   * Calculate percentile\n   */\n  private percentile(arr: number[], p: number): number {\n    const sorted = arr.sort((a, b) => a - b);\n    const index = Math.ceil((p / 100) * sorted.length) - 1;\n    return sorted[Math.max(0, index)];\n  }\n\n  /**\n   * Get all metrics\n   */\n  getMetrics(limit: number = 100) {\n    return this.metrics.slice(-limit);\n  }\n\n  /**\n   * Get performance report\n   */\n  getReport() {\n    const uniqueNames = [...new Set(this.metrics.map((m) => m.name))];\n    const report: any = {};\n\n    uniqueNames.forEach((name) => {\n      report[name] = this.getSummary(name);\n    });\n\n    return report;\n  }\n\n  /**\n   * Clear metrics\n   */\n  clear(): void {\n    this.metrics = [];\n  }\n}\n\nexport default new PerformanceMonitor();\n
