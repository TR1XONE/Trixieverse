/**\n * Advanced Caching Strategy\n * Multi-layer caching with Redis, in-memory, and HTTP caching\n */\n\nimport redis from 'redis';\nimport logger from './logger.js';\n\nconst redisClient = redis.createClient({\n  host: process.env.REDIS_HOST || 'localhost',\n  port: parseInt(process.env.REDIS_PORT || '6379'),\n});\n\ninterface CacheOptions {\n  ttl?: number; // Time to live in seconds\n  tags?: string[]; // Tags for cache invalidation\n  compress?: boolean; // Compress large values\n  namespace?: string; // Cache namespace\n}\n\nclass AdvancedCache {\n  private memoryCache: Map<string, { value: any; expiry: number }> = new Map();\n  private maxMemoryCacheSize = 1000; // Max items in memory cache\n  private compressionThreshold = 1024; // Compress if larger than 1KB\n\n  /**\n   * Get value from cache (memory -> Redis -> null)\n   */\n  async get<T>(key: string, options?: CacheOptions): Promise<T | null> {\n    try {\n      const cacheKey = this.buildKey(key, options?.namespace);\n\n      // Check memory cache first\n      const memoryValue = this.getFromMemoryCache(cacheKey);\n      if (memoryValue !== undefined) {\n        logger.debug(`Cache hit (memory): ${cacheKey}`);\n        return memoryValue as T;\n      }\n\n      // Check Redis\n      const redisValue = await redisClient.get(cacheKey);\n      if (redisValue) {\n        logger.debug(`Cache hit (Redis): ${cacheKey}`);\n        const value = this.deserialize(redisValue);\n        // Store in memory cache\n        this.setMemoryCache(cacheKey, value);\n        return value as T;\n      }\n\n      logger.debug(`Cache miss: ${cacheKey}`);\n      return null;\n    } catch (error) {\n      logger.error({ message: 'Cache get error', error });\n      return null;\n    }\n  }\n\n  /**\n   * Set value in cache (memory + Redis)\n   */\n  async set<T>(key: string, value: T, options?: CacheOptions): Promise<void> {\n    try {\n      const cacheKey = this.buildKey(key, options?.namespace);\n      const ttl = options?.ttl || 3600; // Default 1 hour\n\n      // Serialize value\n      const serialized = this.serialize(value);\n\n      // Store in memory cache\n      this.setMemoryCache(cacheKey, value, ttl);\n\n      // Store in Redis\n      if (ttl > 0) {\n        await redisClient.setex(cacheKey, ttl, serialized);\n      } else {\n        await redisClient.set(cacheKey, serialized);\n      }\n\n      // Store tags for invalidation\n      if (options?.tags && options.tags.length > 0) {\n        for (const tag of options.tags) {\n          const tagKey = `tag:${tag}`;\n          await redisClient.sadd(tagKey, cacheKey);\n          await redisClient.expire(tagKey, ttl);\n        }\n      }\n\n      logger.debug(`Cache set: ${cacheKey}`);\n    } catch (error) {\n      logger.error({ message: 'Cache set error', error });\n    }\n  }\n\n  /**\n   * Delete value from cache\n   */\n  async delete(key: string, namespace?: string): Promise<void> {\n    try {\n      const cacheKey = this.buildKey(key, namespace);\n      this.memoryCache.delete(cacheKey);\n      await redisClient.del(cacheKey);\n      logger.debug(`Cache deleted: ${cacheKey}`);\n    } catch (error) {\n      logger.error({ message: 'Cache delete error', error });\n    }\n  }\n\n  /**\n   * Invalidate cache by tag\n   */\n  async invalidateByTag(tag: string): Promise<void> {\n    try {\n      const tagKey = `tag:${tag}`;\n      const keys = await redisClient.smembers(tagKey);\n\n      for (const key of keys) {\n        this.memoryCache.delete(key);\n        await redisClient.del(key);\n      }\n\n      await redisClient.del(tagKey);\n      logger.debug(`Cache invalidated by tag: ${tag}`);\n    } catch (error) {\n      logger.error({ message: 'Cache invalidate by tag error', error });\n    }\n  }\n\n  /**\n   * Get or set (cache-aside pattern)\n   */\n  async getOrSet<T>(\n    key: string,\n    fn: () => Promise<T>,\n    options?: CacheOptions\n  ): Promise<T> {\n    try {\n      // Try to get from cache\n      const cached = await this.get<T>(key, options);\n      if (cached !== null) {\n        return cached;\n      }\n\n      // Compute value\n      const value = await fn();\n\n      // Store in cache\n      await this.set(key, value, options);\n\n      return value;\n    } catch (error) {\n      logger.error({ message: 'Cache getOrSet error', error });\n      throw error;\n    }\n  }\n\n  /**\n   * Batch get\n   */\n  async mget<T>(keys: string[], namespace?: string): Promise<(T | null)[]> {\n    try {\n      const cacheKeys = keys.map((k) => this.buildKey(k, namespace));\n      const values = await redisClient.mget(cacheKeys);\n      return values.map((v) => (v ? (this.deserialize(v) as T) : null));\n    } catch (error) {\n      logger.error({ message: 'Cache mget error', error });\n      return keys.map(() => null);\n    }\n  }\n\n  /**\n   * Batch set\n   */\n  async mset<T>(data: { [key: string]: T }, options?: CacheOptions): Promise<void> {\n    try {\n      const pipeline = redisClient.multi();\n\n      for (const [key, value] of Object.entries(data)) {\n        const cacheKey = this.buildKey(key, options?.namespace);\n        const serialized = this.serialize(value);\n\n        if (options?.ttl) {\n          pipeline.setex(cacheKey, options.ttl, serialized);\n        } else {\n          pipeline.set(cacheKey, serialized);\n        }\n\n        this.setMemoryCache(cacheKey, value, options?.ttl);\n      }\n\n      await pipeline.exec();\n      logger.debug(`Cache mset: ${Object.keys(data).length} items`);\n    } catch (error) {\n      logger.error({ message: 'Cache mset error', error });\n    }\n  }\n\n  /**\n   * Clear all cache\n   */\n  async clear(): Promise<void> {\n    try {\n      this.memoryCache.clear();\n      await redisClient.flushdb();\n      logger.info('Cache cleared');\n    } catch (error) {\n      logger.error({ message: 'Cache clear error', error });\n    }\n  }\n\n  /**\n   * Get cache statistics\n   */\n  async getStats(): Promise<any> {\n    try {\n      const info = await redisClient.info('stats');\n      const memoryStats = await redisClient.info('memory');\n\n      return {\n        memory: {\n          used: this.memoryCache.size,\n          max: this.maxMemoryCacheSize,\n        },\n        redis: {\n          info,\n          memory: memoryStats,\n        },\n      };\n    } catch (error) {\n      logger.error({ message: 'Failed to get cache stats', error });\n      return null;\n    }\n  }\n\n  /**\n   * Private methods\n   */\n\n  private buildKey(key: string, namespace?: string): string {\n    return namespace ? `${namespace}:${key}` : key;\n  }\n\n  private serialize(value: any): string {\n    const json = JSON.stringify(value);\n    const shouldCompress = json.length > this.compressionThreshold;\n\n    if (shouldCompress) {\n      const zlib = require('zlib');\n      const compressed = zlib.gzipSync(json).toString('base64');\n      return `gzip:${compressed}`;\n    }\n\n    return json;\n  }\n\n  private deserialize(value: string): any {\n    if (value.startsWith('gzip:')) {\n      const zlib = require('zlib');\n      const compressed = Buffer.from(value.substring(5), 'base64');\n      const decompressed = zlib.gunzipSync(compressed).toString();\n      return JSON.parse(decompressed);\n    }\n\n    return JSON.parse(value);\n  }\n\n  private getFromMemoryCache(key: string): any {\n    const item = this.memoryCache.get(key);\n    if (!item) {\n      return undefined;\n    }\n\n    // Check expiry\n    if (item.expiry && Date.now() > item.expiry) {\n      this.memoryCache.delete(key);\n      return undefined;\n    }\n\n    return item.value;\n  }\n\n  private setMemoryCache(key: string, value: any, ttl?: number): void {\n    // Evict oldest item if cache is full\n    if (this.memoryCache.size >= this.maxMemoryCacheSize) {\n      const firstKey = this.memoryCache.keys().next().value;\n      this.memoryCache.delete(firstKey);\n    }\n\n    const expiry = ttl ? Date.now() + ttl * 1000 : undefined;\n    this.memoryCache.set(key, { value, expiry });\n  }\n}\n\nexport default new AdvancedCache();\n
