-- ===================================\n-- DATABASE OPTIMIZATION SCRIPT\n-- ===================================\n\n-- 1. CREATE INDEXES FOR PERFORMANCE\n-- ===================================\n\n-- Users table indexes\nCREATE INDEX IF NOT EXISTS idx_users_email ON users(email);\nCREATE INDEX IF NOT EXISTS idx_users_username ON users(username);\nCREATE INDEX IF NOT EXISTS idx_users_created_at ON users(created_at);\n\n-- Player accounts indexes\nCREATE INDEX IF NOT EXISTS idx_player_accounts_user_id ON player_accounts(user_id);\nCREATE INDEX IF NOT EXISTS idx_player_accounts_rank ON player_accounts(current_rank);\nCREATE INDEX IF NOT EXISTS idx_player_accounts_updated_at ON player_accounts(updated_at);\n\n-- Matches indexes\nCREATE INDEX IF NOT EXISTS idx_matches_user_id ON matches(user_id);\nCREATE INDEX IF NOT EXISTS idx_matches_match_timestamp ON matches(match_timestamp);\nCREATE INDEX IF NOT EXISTS idx_matches_result ON matches(result);\nCREATE INDEX IF NOT EXISTS idx_matches_user_timestamp ON matches(user_id, match_timestamp DESC);\n\n-- Achievements indexes\nCREATE INDEX IF NOT EXISTS idx_achievements_user_id ON achievements(user_id);\nCREATE INDEX IF NOT EXISTS idx_achievements_type ON achievements(achievement_type);\nCREATE INDEX IF NOT EXISTS idx_achievements_unlocked_at ON achievements(unlocked_at);\n\n-- Leaderboard indexes\nCREATE INDEX IF NOT EXISTS idx_leaderboard_rank ON leaderboard(rank);\nCREATE INDEX IF NOT EXISTS idx_leaderboard_xp ON leaderboard(xp DESC);\nCREATE INDEX IF NOT EXISTS idx_leaderboard_updated_at ON leaderboard(updated_at);\n\n-- Social features indexes\nCREATE INDEX IF NOT EXISTS idx_friends_user1_id ON friends(user1_id);\nCREATE INDEX IF NOT EXISTS idx_friends_user2_id ON friends(user2_id);\nCREATE INDEX IF NOT EXISTS idx_friends_status ON friends(status);\n\n-- Coaching circles indexes\nCREATE INDEX IF NOT EXISTS idx_coaching_circles_creator_id ON coaching_circles(creator_id);\nCREATE INDEX IF NOT EXISTS idx_coaching_circles_visibility ON coaching_circles(visibility);\nCREATE INDEX IF NOT EXISTS idx_circle_members_circle_id ON circle_members(circle_id);\nCREATE INDEX IF NOT EXISTS idx_circle_members_user_id ON circle_members(user_id);\n\n-- Notifications indexes\nCREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);\nCREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(is_read);\nCREATE INDEX IF NOT EXISTS idx_notifications_created_at ON notifications(created_at DESC);\n\n-- Skill profiles indexes\nCREATE INDEX IF NOT EXISTS idx_skill_profiles_user_id ON skill_profiles(user_id);\nCREATE INDEX IF NOT EXISTS idx_skill_profiles_updated_at ON skill_profiles(updated_at);\n\n-- 2. OPTIMIZE QUERY PERFORMANCE\n-- ===================================\n\n-- Create materialized view for leaderboard (refresh every hour)\nCREATE MATERIALIZED VIEW IF NOT EXISTS leaderboard_cache AS\nSELECT \n  u.id,\n  u.username,\n  pa.current_rank,\n  l.xp,\n  l.rank,\n  COUNT(DISTINCT m.id) as total_matches,\n  SUM(CASE WHEN m.result = 'win' THEN 1 ELSE 0 END)::float / COUNT(m.id) * 100 as win_rate,\n  AVG(m.kills) as avg_kills,\n  AVG(m.deaths) as avg_deaths,\n  AVG(m.assists) as avg_assists,\n  AVG(m.cs_per_minute) as avg_cs\nFROM users u\nJOIN player_accounts pa ON u.id = pa.user_id\nJOIN leaderboard l ON u.id = l.user_id\nLEFT JOIN matches m ON u.id = m.user_id AND m.match_timestamp > NOW() - INTERVAL '30 days'\nGROUP BY u.id, u.username, pa.current_rank, l.xp, l.rank\nORDER BY l.rank ASC;\n\nCREATE INDEX IF NOT EXISTS idx_leaderboard_cache_rank ON leaderboard_cache(rank);\n\n-- Create materialized view for user stats\nCREATE MATERIALIZED VIEW IF NOT EXISTS user_stats_cache AS\nSELECT \n  u.id,\n  COUNT(DISTINCT m.id) as total_matches,\n  SUM(CASE WHEN m.result = 'win' THEN 1 ELSE 0 END) as total_wins,\n  SUM(CASE WHEN m.result = 'loss' THEN 1 ELSE 0 END) as total_losses,\n  AVG(m.kills) as avg_kills,\n  AVG(m.deaths) as avg_deaths,\n  AVG(m.assists) as avg_assists,\n  AVG(m.cs_per_minute) as avg_cs,\n  AVG(m.damage_dealt) as avg_damage,\n  MAX(m.match_timestamp) as last_match_time\nFROM users u\nLEFT JOIN matches m ON u.id = m.user_id\nGROUP BY u.id;\n\nCREATE INDEX IF NOT EXISTS idx_user_stats_cache_id ON user_stats_cache(id);\n\n-- 3. OPTIMIZE TABLE STRUCTURE\n-- ===================================\n\n-- Add partitioning for large tables (matches table)\nALTER TABLE matches\nADD CONSTRAINT matches_user_id_fk FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;\n\n-- Create partial indexes for common queries\nCREATE INDEX IF NOT EXISTS idx_matches_recent ON matches(user_id, match_timestamp DESC) \nWHERE match_timestamp > NOW() - INTERVAL '30 days';\n\nCREATE INDEX IF NOT EXISTS idx_achievements_recent ON achievements(user_id, unlocked_at DESC) \nWHERE unlocked_at > NOW() - INTERVAL '7 days';\n\n-- 4. VACUUM AND ANALYZE\n-- ===================================\n\nVACUUM ANALYZE;\n\n-- 5. ENABLE QUERY OPTIMIZATION\n-- ===================================\n\n-- Set work_mem for better query performance\nSET work_mem = '256MB';\n\n-- Enable JIT compilation for complex queries\nSET jit = on;\nSET jit_above_cost = 100000;\n\n-- 6. CREATE FUNCTIONS FOR COMMON OPERATIONS\n-- ===================================\n\n-- Function to get user stats efficiently\nCREATE OR REPLACE FUNCTION get_user_stats(p_user_id UUID)\nRETURNS TABLE(\n  total_matches BIGINT,\n  total_wins BIGINT,\n  total_losses BIGINT,\n  avg_kills NUMERIC,\n  avg_deaths NUMERIC,\n  avg_assists NUMERIC,\n  avg_cs NUMERIC,\n  win_rate NUMERIC\n) AS $$\nSELECT \n  COUNT(*)::BIGINT,\n  SUM(CASE WHEN result = 'win' THEN 1 ELSE 0 END)::BIGINT,\n  SUM(CASE WHEN result = 'loss' THEN 1 ELSE 0 END)::BIGINT,\n  AVG(kills),\n  AVG(deaths),\n  AVG(assists),\n  AVG(cs_per_minute),\n  SUM(CASE WHEN result = 'win' THEN 1 ELSE 0 END)::float / COUNT(*) * 100\nFROM matches\nWHERE user_id = p_user_id;\n$$ LANGUAGE SQL STABLE;\n\n-- Function to update leaderboard efficiently\nCREATE OR REPLACE FUNCTION update_leaderboard()\nRETURNS void AS $$\nBEGIN\n  UPDATE leaderboard l\n  SET \n    xp = (SELECT COALESCE(SUM(xp_gained), 0) FROM matches WHERE user_id = l.user_id),\n    updated_at = NOW()\n  WHERE updated_at < NOW() - INTERVAL '1 hour';\nEND;\n$$ LANGUAGE plpgsql;\n\n-- 7. REFRESH MATERIALIZED VIEWS PERIODICALLY\n-- ===================================\n\n-- This should be called by a scheduled job (e.g., pg_cron)\nCREATE OR REPLACE FUNCTION refresh_materialized_views()\nRETURNS void AS $$\nBEGIN\n  REFRESH MATERIALIZED VIEW CONCURRENTLY leaderboard_cache;\n  REFRESH MATERIALIZED VIEW CONCURRENTLY user_stats_cache;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Schedule refresh (requires pg_cron extension)\n-- SELECT cron.schedule('refresh_materialized_views', '0 * * * *', 'SELECT refresh_materialized_views()');\n\n-- 8. ENABLE QUERY LOGGING FOR SLOW QUERIES\n-- ===================================\n\nSET log_min_duration_statement = 1000; -- Log queries slower than 1 second\nSET log_statement = 'mod'; -- Log DML statements\nSET log_duration = on;\n\n-- 9. CONNECTION POOLING CONFIGURATION\n-- ===================================\n\n-- Recommended connection pool settings:\n-- max_connections = 200\n-- shared_buffers = 25% of RAM\n-- effective_cache_size = 50-75% of RAM\n-- maintenance_work_mem = 10% of RAM\n-- checkpoint_completion_target = 0.9\n\n-- 10. STATISTICS\n-- ===================================\n\nANALYZE;\n\n-- Display index usage statistics\nSELECT \n  schemaname,\n  tablename,\n  indexname,\n  idx_scan as index_scans,\n  idx_tup_read as tuples_read,\n  idx_tup_fetch as tuples_fetched\nFROM pg_stat_user_indexes\nORDER BY idx_scan DESC;\n
