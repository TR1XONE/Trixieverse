/**\n * Social Features Service\n * Manage friends, coaching circles, and tournaments\n */\n\nimport db from '../database/connection';\nimport logger from '../utils/logger';\nimport notificationService from './notificationSystemService.js';\n\nclass SocialFeaturesService {\n  /**\n   * Add friend\n   */\n  async addFriend(userId: string, friendId: string): Promise<boolean> {\n    try {\n      // Check if already friends\n      const existing = await db.query(\n        'SELECT id FROM friends WHERE (user_id = $1 AND friend_id = $2) OR (user_id = $2 AND friend_id = $1)',\n        [userId, friendId]\n      );\n\n      if (existing.rows.length > 0) {\n        return false; // Already friends\n      }\n\n      // Add friendship (bidirectional)\n      await db.query(\n        'INSERT INTO friends (user_id, friend_id) VALUES ($1, $2)',\n        [userId, friendId]\n      );\n\n      await db.query(\n        'INSERT INTO friends (user_id, friend_id) VALUES ($1, $2)',\n        [friendId, userId]\n      );\n\n      // Get friend username\n      const friendResult = await db.query('SELECT username FROM users WHERE id = $1', [friendId]);\n      const friendUsername = friendResult.rows[0]?.username;\n\n      // Send notification\n      await notificationService.notifyFriendRequest(friendId, friendUsername);\n\n      logger.info(`Friends added: ${userId} and ${friendId}`);\n      return true;\n    } catch (error) {\n      logger.error({ message: 'Failed to add friend', error });\n      return false;\n    }\n  }\n\n  /**\n   * Remove friend\n   */\n  async removeFriend(userId: string, friendId: string): Promise<boolean> {\n    try {\n      await db.query(\n        'DELETE FROM friends WHERE (user_id = $1 AND friend_id = $2) OR (user_id = $2 AND friend_id = $1)',\n        [userId, friendId]\n      );\n\n      logger.info(`Friend removed: ${userId} and ${friendId}`);\n      return true;\n    } catch (error) {\n      logger.error({ message: 'Failed to remove friend', error });\n      return false;\n    }\n  }\n\n  /**\n   * Get user friends\n   */\n  async getUserFriends(userId: string): Promise<any[]> {\n    try {\n      const result = await db.query(\n        `SELECT u.id, u.username, u.avatar_url, l.level, l.xp, l.win_rate\n         FROM friends f\n         JOIN users u ON f.friend_id = u.id\n         JOIN leaderboard_entries l ON u.id = l.user_id\n         WHERE f.user_id = $1\n         ORDER BY l.xp DESC`,\n        [userId]\n      );\n\n      return result.rows;\n    } catch (error) {\n      logger.error({ message: 'Failed to get user friends', error });\n      return [];\n    }\n  }\n\n  /**\n   * Create coaching circle\n   */\n  async createCoachingCircle(\n    userId: string,\n    name: string,\n    description: string,\n    isPublic: boolean = false\n  ): Promise<string | null> {\n    try {\n      const result = await db.query(\n        `INSERT INTO coaching_circles (name, description, created_by, is_public, member_count)\n         VALUES ($1, $2, $3, $4, 1)\n         RETURNING id`,\n        [name, description, userId, isPublic]\n      );\n\n      const circleId = result.rows[0].id;\n\n      // Add creator as member\n      await db.query(\n        'INSERT INTO circle_members (circle_id, user_id) VALUES ($1, $2)',\n        [circleId, userId]\n      );\n\n      logger.info(`Coaching circle created: ${circleId}`);\n      return circleId;\n    } catch (error) {\n      logger.error({ message: 'Failed to create coaching circle', error });\n      return null;\n    }\n  }\n\n  /**\n   * Join coaching circle\n   */\n  async joinCoachingCircle(userId: string, circleId: string): Promise<boolean> {\n    try {\n      // Check if already member\n      const existing = await db.query(\n        'SELECT id FROM circle_members WHERE circle_id = $1 AND user_id = $2',\n        [circleId, userId]\n      );\n\n      if (existing.rows.length > 0) {\n        return false; // Already member\n      }\n\n      // Add member\n      await db.query(\n        'INSERT INTO circle_members (circle_id, user_id) VALUES ($1, $2)',\n        [circleId, userId]\n      );\n\n      // Update member count\n      await db.query(\n        'UPDATE coaching_circles SET member_count = member_count + 1 WHERE id = $1',\n        [circleId]\n      );\n\n      logger.info(`User ${userId} joined circle ${circleId}`);\n      return true;\n    } catch (error) {\n      logger.error({ message: 'Failed to join coaching circle', error });\n      return false;\n    }\n  }\n\n  /**\n   * Leave coaching circle\n   */\n  async leaveCoachingCircle(userId: string, circleId: string): Promise<boolean> {\n    try {\n      await db.query(\n        'DELETE FROM circle_members WHERE circle_id = $1 AND user_id = $2',\n        [circleId, userId]\n      );\n\n      // Update member count\n      await db.query(\n        'UPDATE coaching_circles SET member_count = member_count - 1 WHERE id = $1',\n        [circleId]\n      );\n\n      logger.info(`User ${userId} left circle ${circleId}`);\n      return true;\n    } catch (error) {\n      logger.error({ message: 'Failed to leave coaching circle', error });\n      return false;\n    }\n  }\n\n  /**\n   * Get coaching circles\n   */\n  async getCoachingCircles(userId: string): Promise<any[]> {\n    try {\n      const result = await db.query(\n        `SELECT cc.* FROM coaching_circles cc\n         JOIN circle_members cm ON cc.id = cm.circle_id\n         WHERE cm.user_id = $1\n         ORDER BY cc.created_at DESC`,\n        [userId]\n      );\n\n      return result.rows;\n    } catch (error) {\n      logger.error({ message: 'Failed to get coaching circles', error });\n      return [];\n    }\n  }\n\n  /**\n   * Get circle members\n   */\n  async getCircleMembers(circleId: string): Promise<any[]> {\n    try {\n      const result = await db.query(\n        `SELECT u.id, u.username, u.avatar_url, l.level, l.xp, l.win_rate\n         FROM circle_members cm\n         JOIN users u ON cm.user_id = u.id\n         JOIN leaderboard_entries l ON u.id = l.user_id\n         WHERE cm.circle_id = $1\n         ORDER BY l.xp DESC`,\n        [circleId]\n      );\n\n      return result.rows;\n    } catch (error) {\n      logger.error({ message: 'Failed to get circle members', error });\n      return [];\n    }\n  }\n\n  /**\n   * Create tournament\n   */\n  async createTournament(\n    circleId: string,\n    name: string,\n    description: string,\n    startDate: Date,\n    endDate: Date\n  ): Promise<string | null> {\n    try {\n      const result = await db.query(\n        `INSERT INTO tournaments (circle_id, name, description, start_date, end_date, status)\n         VALUES ($1, $2, $3, $4, $5, 'upcoming')\n         RETURNING id`,\n        [circleId, name, description, startDate, endDate]\n      );\n\n      logger.info(`Tournament created: ${result.rows[0].id}`);\n      return result.rows[0].id;\n    } catch (error) {\n      logger.error({ message: 'Failed to create tournament', error });\n      return null;\n    }\n  }\n\n  /**\n   * Register for tournament\n   */\n  async registerForTournament(userId: string, tournamentId: string): Promise<boolean> {\n    try {\n      // Check if already registered\n      const existing = await db.query(\n        'SELECT id FROM tournament_participants WHERE tournament_id = $1 AND user_id = $2',\n        [tournamentId, userId]\n      );\n\n      if (existing.rows.length > 0) {\n        return false; // Already registered\n      }\n\n      // Register\n      await db.query(\n        'INSERT INTO tournament_participants (tournament_id, user_id) VALUES ($1, $2)',\n        [tournamentId, userId]\n      );\n\n      logger.info(`User ${userId} registered for tournament ${tournamentId}`);\n      return true;\n    } catch (error) {\n      logger.error({ message: 'Failed to register for tournament', error });\n      return false;\n    }\n  }\n\n  /**\n   * Get public circles\n   */\n  async getPublicCircles(limit: number = 20): Promise<any[]> {\n    try {\n      const result = await db.query(\n        `SELECT cc.*, u.username as creator_username, COUNT(cm.id) as member_count\n         FROM coaching_circles cc\n         JOIN users u ON cc.created_by = u.id\n         LEFT JOIN circle_members cm ON cc.id = cm.circle_id\n         WHERE cc.is_public = true\n         GROUP BY cc.id, u.username\n         ORDER BY member_count DESC\n         LIMIT $1`,\n        [limit]\n      );\n\n      return result.rows;\n    } catch (error) {\n      logger.error({ message: 'Failed to get public circles', error });\n      return [];\n    }\n  }\n}\n\nexport default new SocialFeaturesService();\n
