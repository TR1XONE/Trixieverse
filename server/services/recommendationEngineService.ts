/**\n * AI Recommendation Engine\n * Personalized recommendations based on player data\n */\n\nimport db from '../database/connection';\nimport logger from '../utils/logger';\nimport { OpenAI } from 'openai';\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n});\n\ninterface PlayerProfile {\n  username: string;\n  rank: string;\n  mainRole: string;\n  mainChampion: string;\n  winRate: number;\n  averageKDA: { kills: number; deaths: number; assists: number };\n  averageCSPerMinute: number;\n  recentMatches: any[];\n}\n\ninterface Recommendation {\n  type: 'champion' | 'role' | 'playstyle' | 'improvement' | 'learning';\n  title: string;\n  description: string;\n  reasoning: string;\n  priority: 'high' | 'medium' | 'low';\n}\n\nclass RecommendationEngineService {\n  /**\n   * Generate personalized recommendations\n   */\n  async generateRecommendations(userId: string): Promise<Recommendation[]> {\n    try {\n      // Get player profile\n      const profile = await this.getPlayerProfile(userId);\n      if (!profile) return [];\n\n      // Get recommendations from different sources\n      const recommendations: Recommendation[] = [];\n\n      // Champion recommendations\n      const championRecs = await this.getChampionRecommendations(profile);\n      recommendations.push(...championRecs);\n\n      // Role recommendations\n      const roleRecs = await this.getRoleRecommendations(profile);\n      recommendations.push(...roleRecs);\n\n      // Playstyle recommendations\n      const playstyleRecs = await this.getPlaystyleRecommendations(profile);\n      recommendations.push(...playstyleRecs);\n\n      // Improvement recommendations\n      const improvementRecs = await this.getImprovementRecommendations(profile);\n      recommendations.push(...improvementRecs);\n\n      // AI-generated recommendations\n      const aiRecs = await this.getAIRecommendations(profile);\n      recommendations.push(...aiRecs);\n\n      // Sort by priority\n      return recommendations.sort((a, b) => {\n        const priorityMap = { high: 0, medium: 1, low: 2 };\n        return priorityMap[a.priority] - priorityMap[b.priority];\n      });\n    } catch (error) {\n      logger.error({ message: 'Failed to generate recommendations', error });\n      return [];\n    }\n  }\n\n  /**\n   * Get player profile\n   */\n  private async getPlayerProfile(userId: string): Promise<PlayerProfile | null> {\n    try {\n      const userResult = await db.query('SELECT username FROM users WHERE id = $1', [userId]);\n      if (userResult.rows.length === 0) return null;\n\n      const matchResult = await db.query(\n        `SELECT \n           (SELECT current_rank FROM player_accounts WHERE user_id = $1 LIMIT 1) as rank,\n           role as main_role,\n           champion as main_champion,\n           SUM(CASE WHEN result = 'win' THEN 1 ELSE 0 END)::float / COUNT(*) as win_rate,\n           AVG(kills) as avg_kills,\n           AVG(deaths) as avg_deaths,\n           AVG(assists) as avg_assists,\n           AVG(cs_per_minute) as avg_cs_per_minute\n         FROM matches\n         WHERE user_id = $1\n         GROUP BY role, champion\n         ORDER BY COUNT(*) DESC\n         LIMIT 1`,\n        [userId]\n      );\n\n      if (matchResult.rows.length === 0) return null;\n\n      const matchData = matchResult.rows[0];\n\n      // Get recent matches\n      const recentResult = await db.query(\n        `SELECT * FROM matches WHERE user_id = $1 ORDER BY match_timestamp DESC LIMIT 10`,\n        [userId]\n      );\n\n      return {\n        username: userResult.rows[0].username,\n        rank: matchData.rank || 'UNRANKED',\n        mainRole: matchData.main_role,\n        mainChampion: matchData.main_champion,\n        winRate: matchData.win_rate * 100,\n        averageKDA: {\n          kills: matchData.avg_kills,\n          deaths: matchData.avg_deaths,\n          assists: matchData.avg_assists,\n        },\n        averageCSPerMinute: matchData.avg_cs_per_minute,\n        recentMatches: recentResult.rows,\n      };\n    } catch (error) {\n      logger.error({ message: 'Failed to get player profile', error });\n      return null;\n    }\n  }\n\n  /**\n   * Get champion recommendations\n   */\n  private async getChampionRecommendations(profile: PlayerProfile): Promise<Recommendation[]> {\n    const recommendations: Recommendation[] = [];\n\n    // If win rate is low, suggest trying different champions\n    if (profile.winRate < 48) {\n      recommendations.push({\n        type: 'champion',\n        title: 'Expand Your Champion Pool',\n        description: `Your win rate with ${profile.mainChampion} is ${profile.winRate.toFixed(1)}%. Try learning 1-2 new champions to find better matchups.`,\n        reasoning: 'Low win rate suggests current champion may not be optimal for current meta',\n        priority: 'high',\n      });\n    }\n\n    // If playing many champions, suggest focusing\n    if (profile.mainChampion === 'Multiple') {\n      recommendations.push({\n        type: 'champion',\n        title: 'Focus on One Champion',\n        description: 'Playing too many different champions. Pick 1-2 main champions to improve faster.',\n        reasoning: 'Champion mastery requires focus and repetition',\n        priority: 'high',\n      });\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Get role recommendations\n   */\n  private async getRoleRecommendations(profile: PlayerProfile): Promise<Recommendation[]> {\n    const recommendations: Recommendation[] = [];\n\n    // If playing support but low damage, suggest learning damage role\n    if (profile.mainRole === 'Support' && profile.averageKDA.kills < 2) {\n      recommendations.push({\n        type: 'role',\n        title: 'Consider Learning a Damage Role',\n        description: 'You have strong game knowledge. Try learning a damage role to increase impact.',\n        reasoning: 'Support players often have good macro understanding',\n        priority: 'medium',\n      });\n    }\n\n    // If playing damage role with high deaths, suggest learning support\n    if (['Mid', 'ADC', 'Baron'].includes(profile.mainRole) && profile.averageKDA.deaths > 5) {\n      recommendations.push({\n        type: 'role',\n        title: 'Practice Positioning',\n        description: 'Your death count is high. Focus on positioning and map awareness.',\n        reasoning: 'Damage dealers need strong positioning skills',\n        priority: 'high',\n      });\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Get playstyle recommendations\n   */\n  private async getPlaystyleRecommendations(profile: PlayerProfile): Promise<Recommendation[]> {\n    const recommendations: Recommendation[] = [];\n\n    // High CS, low kills = farming focused\n    if (profile.averageCSPerMinute > 7 && profile.averageKDA.kills < 4) {\n      recommendations.push({\n        type: 'playstyle',\n        title: 'Increase Aggression',\n        description: 'You farm well but could be more aggressive. Work on trading and securing kills.',\n        reasoning: 'Farming is important but kills close games',\n        priority: 'medium',\n      });\n    }\n\n    // Low CS, high kills = aggressive\n    if (profile.averageCSPerMinute < 5 && profile.averageKDA.kills > 6) {\n      recommendations.push({\n        type: 'playstyle',\n        title: 'Improve CS',\n        description: 'You get kills but miss CS. Balance aggression with farming.',\n        reasoning: 'CS is more reliable income than kills',\n        priority: 'high',\n      });\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Get improvement recommendations\n   */\n  private async getImprovementRecommendations(profile: PlayerProfile): Promise<Recommendation[]> {\n    const recommendations: Recommendation[] = [];\n\n    // High deaths\n    if (profile.averageKDA.deaths > 4) {\n      recommendations.push({\n        type: 'improvement',\n        title: 'Reduce Deaths',\n        description: 'Focus on map awareness and positioning to reduce deaths.',\n        reasoning: 'Each death is 40+ seconds of lost game time',\n        priority: 'high',\n      });\n    }\n\n    // Low KDA\n    const kda = (profile.averageKDA.kills + profile.averageKDA.assists) / Math.max(profile.averageKDA.deaths, 1);\n    if (kda < 2) {\n      recommendations.push({\n        type: 'improvement',\n        title: 'Improve KDA',\n        description: 'Your KDA is low. Focus on securing kills and assists.',\n        reasoning: 'KDA reflects overall impact on the game',\n        priority: 'medium',\n      });\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Get AI-generated recommendations\n   */\n  private async getAIRecommendations(profile: PlayerProfile): Promise<Recommendation[]> {\n    try {\n      const prompt = `You are a Wild Rift coaching expert. Based on this player profile, provide 2-3 specific, actionable recommendations:\n\nPlayer: ${profile.username}\nRank: ${profile.rank}\nMain Role: ${profile.mainRole}\nMain Champion: ${profile.mainChampion}\nWin Rate: ${profile.winRate.toFixed(1)}%\nAverage KDA: ${profile.averageKDA.kills.toFixed(1)}/${profile.averageKDA.deaths.toFixed(1)}/${profile.averageKDA.assists.toFixed(1)}\nCS per Minute: ${profile.averageCSPerMinute.toFixed(1)}\n\nProvide recommendations in JSON format:\n[\n  {\n    \"title\": \"...\",\n    \"description\": \"...\",\n    \"reasoning\": \"...\",\n    \"priority\": \"high|medium|low\"\n  }\n]\n\nOnly return valid JSON, no other text.`;\n\n      const response = await openai.chat.completions.create({\n        model: 'gpt-4.1-mini',\n        messages: [\n          {\n            role: 'user',\n            content: prompt,\n          },\n        ],\n        temperature: 0.7,\n        max_tokens: 500,\n      });\n\n      const content = response.choices[0]?.message?.content;\n      if (!content) return [];\n\n      const recommendations = JSON.parse(content);\n      return recommendations.map((rec: any) => ({\n        type: 'learning' as const,\n        ...rec,\n      }));\n    } catch (error) {\n      logger.error({ message: 'Failed to get AI recommendations', error });\n      return [];\n    }\n  }\n\n  /**\n   * Save recommendations to database\n   */\n  async saveRecommendations(userId: string, recommendations: Recommendation[]): Promise<boolean> {\n    try {\n      for (const rec of recommendations) {\n        await db.query(\n          `INSERT INTO recommendations (user_id, type, title, description, reasoning, priority)\n           VALUES ($1, $2, $3, $4, $5, $6)\n           ON CONFLICT (user_id, type, title) DO UPDATE SET updated_at = CURRENT_TIMESTAMP`,\n          [userId, rec.type, rec.title, rec.description, rec.reasoning, rec.priority]\n        );\n      }\n\n      return true;\n    } catch (error) {\n      logger.error({ message: 'Failed to save recommendations', error });\n      return false;\n    }\n  }\n}\n\nexport default new RecommendationEngineService();\n
