/**\n * Gamification System Service\n * Manage achievements, badges, XP, levels, and streaks\n */\n\nimport db from '../database/connection';\nimport logger from '../utils/logger';\nimport notificationService from './notificationSystemService.js';\n\ninterface Achievement {\n  key: string;\n  title: string;\n  description: string;\n  icon: string;\n  rarity: 'common' | 'rare' | 'epic' | 'legendary';\n  xpReward: number;\n  condition: (stats: any) => boolean;\n}\n\nconst ACHIEVEMENTS: Achievement[] = [\n  {\n    key: 'first_win',\n    title: 'First Victory',\n    description: 'Win your first match',\n    icon: 'ðŸ†',\n    rarity: 'common',\n    xpReward: 100,\n    condition: (stats) => stats.result === 'win',\n  },\n  {\n    key: 'perfect_kda',\n    title: 'Perfect KDA',\n    description: 'Get a match with 0 deaths',\n    icon: 'ðŸ’Ž',\n    rarity: 'rare',\n    xpReward: 500,\n    condition: (stats) => stats.deaths === 0 && stats.kills >= 5,\n  },\n  {\n    key: 'cs_master',\n    title: 'CS Master',\n    description: 'Achieve 10+ CS per minute',\n    icon: 'ðŸ’°',\n    rarity: 'epic',\n    xpReward: 750,\n    condition: (stats) => stats.csPerMinute >= 10,\n  },\n  {\n    key: 'killing_spree',\n    title: 'Killing Spree',\n    description: 'Get 10+ kills in a match',\n    icon: 'ðŸ”¥',\n    rarity: 'epic',\n    xpReward: 1000,\n    condition: (stats) => stats.kills >= 10,\n  },\n  {\n    key: 'carry_game',\n    title: 'Carry',\n    description: 'Deal 40%+ of team damage',\n    icon: 'âš”ï¸',\n    rarity: 'rare',\n    xpReward: 600,\n    condition: (stats) => stats.damageDealtPercentage >= 40,\n  },\n  {\n    key: 'teamfight_master',\n    title: 'Teamfight Master',\n    description: 'Get 10+ assists in a match',\n    icon: 'ðŸ¤',\n    rarity: 'rare',\n    xpReward: 500,\n    condition: (stats) => stats.assists >= 10,\n  },\n  {\n    key: 'survivor',\n    title: 'Survivor',\n    description: 'Win 5 matches in a row',\n    icon: 'ðŸ›¡ï¸',\n    rarity: 'epic',\n    xpReward: 1500,\n    condition: (stats) => stats.winStreak >= 5,\n  },\n  {\n    key: 'rank_up_master',\n    title: 'Rank Up Master',\n    description: 'Reach Gold rank',\n    icon: 'ðŸ“ˆ',\n    rarity: 'legendary',\n    xpReward: 2000,\n    condition: (stats) => ['GOLD', 'PLATINUM', 'DIAMOND', 'MASTER'].includes(stats.rank),\n  },\n  {\n    key: 'champion_specialist',\n    title: 'Champion Specialist',\n    description: 'Reach mastery level 5 with a champion',\n    icon: 'ðŸŽ¯',\n    rarity: 'rare',\n    xpReward: 800,\n    condition: (stats) => stats.championMastery >= 5,\n  },\n  {\n    key: 'legendary_performance',\n    title: 'Legendary Performance',\n    description: 'Achieve 90+ performance score',\n    icon: 'ðŸ‘‘',\n    rarity: 'legendary',\n    xpReward: 2500,\n    condition: (stats) => stats.performanceScore >= 90,\n  },\n];\n\nclass GamificationSystemService {\n  /**\n   * Check and unlock achievements\n   */\n  async checkAndUnlockAchievements(userId: string, stats: any): Promise<Achievement[]> {\n    try {\n      const unlockedAchievements: Achievement[] = [];\n\n      for (const achievement of ACHIEVEMENTS) {\n        // Check if achievement is already unlocked\n        const existing = await db.query(\n          'SELECT id FROM achievements WHERE user_id = $1 AND achievement_key = $2',\n          [userId, achievement.key]\n        );\n\n        if (existing.rows.length > 0) {\n          continue; // Already unlocked\n        }\n\n        // Check condition\n        if (achievement.condition(stats)) {\n          // Unlock achievement\n          await db.query(\n            `INSERT INTO achievements (user_id, achievement_key, title, description, rarity, icon_url)\n             VALUES ($1, $2, $3, $4, $5, $6)`,\n            [userId, achievement.key, achievement.title, achievement.description, achievement.rarity, achievement.icon]\n          );\n\n          // Add XP\n          await this.addXP(userId, achievement.xpReward);\n\n          // Send notification\n          await notificationService.notifyAchievementUnlocked(userId, {\n            title: achievement.title,\n            description: achievement.description,\n            icon: achievement.icon,\n          });\n\n          unlockedAchievements.push(achievement);\n          logger.info(`Achievement unlocked: ${achievement.key} for user ${userId}`);\n        }\n      }\n\n      return unlockedAchievements;\n    } catch (error) {\n      logger.error({ message: 'Failed to check achievements', error });\n      return [];\n    }\n  }\n\n  /**\n   * Add XP to user\n   */\n  async addXP(userId: string, xp: number): Promise<boolean> {\n    try {\n      // Get current XP and level\n      const result = await db.query(\n        'SELECT xp, level FROM leaderboard_entries WHERE user_id = $1',\n        [userId]\n      );\n\n      if (result.rows.length === 0) {\n        // Create new entry\n        await db.query(\n          `INSERT INTO leaderboard_entries (user_id, xp, level)\n           VALUES ($1, $2, 1)`,\n          [userId, xp]\n        );\n      } else {\n        const currentXP = result.rows[0].xp || 0;\n        const currentLevel = result.rows[0].level || 1;\n        const newXP = currentXP + xp;\n        const xpPerLevel = 1000;\n        const newLevel = Math.floor(newXP / xpPerLevel) + 1;\n\n        // Check for level up\n        if (newLevel > currentLevel) {\n          await notificationService.notifySystem(\n            userId,\n            `ðŸŽ‰ Level Up!`,\n            `You've reached level ${newLevel}!`,\n            { level: newLevel }\n          );\n        }\n\n        // Update XP and level\n        await db.query(\n          `UPDATE leaderboard_entries SET xp = $1, level = $2 WHERE user_id = $3`,\n          [newXP, newLevel, userId]\n        );\n      }\n\n      return true;\n    } catch (error) {\n      logger.error({ message: 'Failed to add XP', error });\n      return false;\n    }\n  }\n\n  /**\n   * Update win streak\n   */\n  async updateWinStreak(userId: string, result: 'win' | 'loss'): Promise<number> {\n    try {\n      const lastMatch = await db.query(\n        `SELECT result FROM matches WHERE user_id = $1 ORDER BY match_timestamp DESC LIMIT 1`,\n        [userId]\n      );\n\n      if (lastMatch.rows.length === 0) {\n        return result === 'win' ? 1 : 0;\n      }\n\n      let streak = 0;\n      const matches = await db.query(\n        `SELECT result FROM matches WHERE user_id = $1 ORDER BY match_timestamp DESC LIMIT 20`,\n        [userId]\n      );\n\n      for (const match of matches.rows) {\n        if ((result === 'win' && match.result === 'win') || (result === 'loss' && match.result === 'loss')) {\n          streak++;\n        } else {\n          break;\n        }\n      }\n\n      return streak;\n    } catch (error) {\n      logger.error({ message: 'Failed to update win streak', error });\n      return 0;\n    }\n  }\n\n  /**\n   * Get user achievements\n   */\n  async getUserAchievements(userId: string): Promise<any[]> {\n    try {\n      const result = await db.query(\n        `SELECT * FROM achievements WHERE user_id = $1 ORDER BY unlocked_at DESC`,\n        [userId]\n      );\n\n      return result.rows;\n    } catch (error) {\n      logger.error({ message: 'Failed to get user achievements', error });\n      return [];\n    }\n  }\n\n  /**\n   * Get user level and XP\n   */\n  async getUserLevel(userId: string): Promise<{ level: number; xp: number; xpToNextLevel: number }> {\n    try {\n      const result = await db.query(\n        'SELECT xp, level FROM leaderboard_entries WHERE user_id = $1',\n        [userId]\n      );\n\n      if (result.rows.length === 0) {\n        return { level: 1, xp: 0, xpToNextLevel: 1000 };\n      }\n\n      const xpPerLevel = 1000;\n      const xp = result.rows[0].xp || 0;\n      const level = result.rows[0].level || 1;\n      const xpToNextLevel = xpPerLevel - (xp % xpPerLevel);\n\n      return { level, xp, xpToNextLevel };\n    } catch (error) {\n      logger.error({ message: 'Failed to get user level', error });\n      return { level: 1, xp: 0, xpToNextLevel: 1000 };\n    }\n  }\n\n  /**\n   * Get leaderboard\n   */\n  async getLeaderboard(limit: number = 100): Promise<any[]> {\n    try {\n      const result = await db.query(\n        `SELECT u.username, l.xp, l.level, l.win_rate, l.matches_played\n         FROM leaderboard_entries l\n         JOIN users u ON l.user_id = u.id\n         ORDER BY l.xp DESC\n         LIMIT $1`,\n        [limit]\n      );\n\n      return result.rows.map((row, idx) => ({\n        rank: idx + 1,\n        ...row,\n      }));\n    } catch (error) {\n      logger.error({ message: 'Failed to get leaderboard', error });\n      return [];\n    }\n  }\n\n  /**\n   * Get user rank\n   */\n  async getUserRank(userId: string): Promise<number | null> {\n    try {\n      const result = await db.query(\n        `SELECT COUNT(*) as rank FROM leaderboard_entries\n         WHERE xp > (SELECT xp FROM leaderboard_entries WHERE user_id = $1)`,\n        [userId]\n      );\n\n      return result.rows[0].rank + 1;\n    } catch (error) {\n      logger.error({ message: 'Failed to get user rank', error });\n      return null;\n    }\n  }\n}\n\nexport default new GamificationSystemService();\n
