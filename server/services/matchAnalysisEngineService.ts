/**\n * Match Analysis Engine\n * Detailed analysis of player matches\n */\n\nimport db from '../database/connection.js';\nimport logger from '../utils/logger.js';\nimport riotApiService from './riotApiIntegrationService.js';\nimport notificationService from './notificationSystemService.js';\n\ninterface MatchAnalysis {\n  matchId: string;\n  result: 'win' | 'loss';\n  duration: number;\n  champion: string;\n  role: string;\n  kda: { kills: number; deaths: number; assists: number };\n  cs: number;\n  csPerMinute: number;\n  gold: number;\n  goldPerMinute: number;\n  damageDealt: number;\n  damageTaken: number;\n  damageDealtPercentage: number;\n  performanceScore: number;\n  highlights: string[];\n  improvements: string[];\n  coachInsights: string;\n}\n\nclass MatchAnalysisEngineService {\n  /**\n   * Analyze a single match\n   */\n  async analyzeMatch(matchId: string, puuid: string): Promise<MatchAnalysis | null> {\n    try {\n      const matchDetails = await riotApiService.getMatchDetails(matchId);\n      if (!matchDetails) return null;\n\n      // Find player in match\n      const playerParticipant = matchDetails.info.participants.find(\n        (p: any) => p.puuid === puuid\n      );\n\n      if (!playerParticipant) {\n        logger.error({ message: 'Player not found in match' });\n        return null;\n      }\n\n      // Calculate metrics\n      const duration = matchDetails.info.gameDuration / 60; // Convert to minutes\n      const kda = {\n        kills: playerParticipant.kills,\n        deaths: playerParticipant.deaths,\n        assists: playerParticipant.assists,\n      };\n      const cs = playerParticipant.totalMinionsKilled + playerParticipant.neutralMinionsKilled;\n      const csPerMinute = cs / duration;\n      const gold = playerParticipant.goldEarned;\n      const goldPerMinute = gold / duration;\n      const damageDealt = playerParticipant.totalDamageDealtToChampions;\n      const damageTaken = playerParticipant.totalDamageTaken;\n      const damageDealtPercentage = this.calculateDamagePercentage(\n        playerParticipant,\n        matchDetails.info.participants\n      );\n\n      // Determine result\n      const result = playerParticipant.win ? 'win' : 'loss';\n\n      // Calculate performance score (0-100)\n      const performanceScore = this.calculatePerformanceScore({\n        kda,\n        csPerMinute,\n        damageDealtPercentage,\n        result,\n        duration,\n      });\n\n      // Generate highlights and improvements\n      const highlights = this.generateHighlights({\n        kda,\n        csPerMinute,\n        damageDealtPercentage,\n        result,\n      });\n\n      const improvements = this.generateImprovements({\n        kda,\n        csPerMinute,\n        damageDealtPercentage,\n        result,\n      });\n\n      // Generate coach insights\n      const coachInsights = this.generateCoachInsights({\n        kda,\n        csPerMinute,\n        damageDealtPercentage,\n        result,\n        duration,\n        champion: playerParticipant.championName,\n      });\n\n      const analysis: MatchAnalysis = {\n        matchId,\n        result,\n        duration: Math.round(duration),\n        champion: playerParticipant.championName,\n        role: playerParticipant.role,\n        kda,\n        cs,\n        csPerMinute: Math.round(csPerMinute * 100) / 100,\n        gold,\n        goldPerMinute: Math.round(goldPerMinute * 100) / 100,\n        damageDealt,\n        damageTaken,\n        damageDealtPercentage: Math.round(damageDealtPercentage * 100) / 100,\n        performanceScore,\n        highlights,\n        improvements,\n        coachInsights,\n      };\n\n      return analysis;\n    } catch (error) {\n      logger.error({ message: 'Failed to analyze match', error });\n      return null;\n    }\n  }\n\n  /**\n   * Calculate damage percentage\n   */\n  private calculateDamagePercentage(player: any, allParticipants: any[]): number {\n    const teamDamage = allParticipants\n      .filter((p: any) => p.teamId === player.teamId)\n      .reduce((sum: number, p: any) => sum + p.totalDamageDealtToChampions, 0);\n\n    return teamDamage > 0 ? (player.totalDamageDealtToChampions / teamDamage) * 100 : 0;\n  }\n\n  /**\n   * Calculate performance score (0-100)\n   */\n  private calculatePerformanceScore(metrics: any): number {\n    let score = 50; // Base score\n\n    // KDA scoring\n    const kdaRatio = (metrics.kda.kills + metrics.kda.assists) / Math.max(metrics.kda.deaths, 1);\n    score += Math.min(kdaRatio * 5, 20);\n\n    // CS scoring\n    const csScore = Math.min(metrics.csPerMinute / 10 * 15, 15);\n    score += csScore;\n\n    // Damage scoring\n    const damageScore = Math.min(metrics.damageDealtPercentage / 5, 15);\n    score += damageScore;\n\n    // Win/Loss bonus\n    if (metrics.result === 'win') {\n      score += 10;\n    } else {\n      score -= 5;\n    }\n\n    // Duration bonus (longer matches = more impact)\n    if (metrics.duration > 30) {\n      score += 5;\n    }\n\n    return Math.min(Math.max(Math.round(score), 0), 100);\n  }\n\n  /**\n   * Generate highlights\n   */\n  private generateHighlights(metrics: any): string[] {\n    const highlights: string[] = [];\n\n    if (metrics.kda.kills >= 10) {\n      highlights.push('ðŸ”¥ High kill count');\n    }\n\n    if (metrics.kda.deaths <= 2) {\n      highlights.push('ðŸ›¡ï¸ Excellent survivability');\n    }\n\n    if (metrics.csPerMinute >= 8) {\n      highlights.push('ðŸ’° Great CS');\n    }\n\n    if (metrics.damageDealtPercentage >= 30) {\n      highlights.push('âš”ï¸ High damage output');\n    }\n\n    if (metrics.result === 'win') {\n      highlights.push('ðŸ† Victory');\n    }\n\n    return highlights.length > 0 ? highlights : ['âœ¨ Good effort'];\n  }\n\n  /**\n   * Generate improvements\n   */\n  private generateImprovements(metrics: any): string[] {\n    const improvements: string[] = [];\n\n    if (metrics.kda.deaths >= 5) {\n      improvements.push('ðŸ“‰ Reduce deaths - focus on positioning');\n    }\n\n    if (metrics.csPerMinute < 5) {\n      improvements.push('ðŸŽ¯ Improve CS - last-hit more minions');\n    }\n\n    if (metrics.damageDealtPercentage < 20) {\n      improvements.push('ðŸ’ª Increase damage - be more aggressive');\n    }\n\n    if (metrics.result === 'loss') {\n      improvements.push('ðŸŽ“ Review this loss - learn from mistakes');\n    }\n\n    return improvements.length > 0 ? improvements : ['ðŸ‘ Keep improving'];\n  }\n\n  /**\n   * Generate coach insights\n   */\n  private generateCoachInsights(metrics: any): string {\n    const { kda, csPerMinute, damageDealtPercentage, result, duration, champion } = metrics;\n\n    let insight = '';\n\n    if (result === 'win') {\n      if (csPerMinute >= 8 && kda.deaths <= 2) {\n        insight = `Excellent game with ${champion}! Your CS and survivability were top-notch. Keep maintaining this level of play.`;\n      } else if (kda.kills >= 10) {\n        insight = `Great carry performance! You dominated the game with ${kda.kills} kills. Focus on translating this into more wins.`;\n      } else {\n        insight = `Good win! You played ${champion} well. Continue building on this foundation.`;\n      }\n    } else {\n      if (kda.deaths >= 5) {\n        insight = `You had ${kda.deaths} deaths this game. Focus on map awareness and positioning to reduce deaths.`;\n      } else if (csPerMinute < 5) {\n        insight = `Your CS was lower than usual. Spend more time farming minions to scale better into the game.`;\n      } else {\n        insight = `Close game! You played well but couldn't secure the win. Review the key moments and learn from them.`;\n      }\n    }\n\n    return insight;\n  }\n\n  /**\n   * Save match analysis to database\n   */\n  async saveMatchAnalysis(userId: string, analysis: MatchAnalysis): Promise<boolean> {\n    try {\n      await db.query(\n        `INSERT INTO matches (\n           user_id, champion, role, result, duration,\n           kills, deaths, assists, cs_per_minute,\n           gold_earned, damage_dealt, damage_taken,\n           performance_score, analysis_data\n         ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)`,\n        [\n          userId,\n          analysis.champion,\n          analysis.role,\n          analysis.result,\n          analysis.duration,\n          analysis.kda.kills,\n          analysis.kda.deaths,\n          analysis.kda.assists,\n          analysis.csPerMinute,\n          analysis.gold,\n          analysis.damageDealt,\n          analysis.damageTaken,\n          analysis.performanceScore,\n          JSON.stringify({\n            highlights: analysis.highlights,\n            improvements: analysis.improvements,\n            coachInsights: analysis.coachInsights,\n          }),\n        ]\n      );\n\n      // Send notification\n      await notificationService.notifyMatchAnalysis(userId, {\n        result: analysis.result,\n        performance: analysis.performanceScore,\n        duration: analysis.duration,\n      });\n\n      logger.info(`Match analysis saved for user ${userId}`);\n      return true;\n    } catch (error) {\n      logger.error({ message: 'Failed to save match analysis', error });\n      return false;\n    }\n  }\n\n  /**\n   * Get match history analysis\n   */\n  async getMatchHistoryAnalysis(userId: string, limit: number = 10): Promise<any[]> {\n    try {\n      const result = await db.query(\n        `SELECT * FROM matches \n         WHERE user_id = $1 \n         ORDER BY match_timestamp DESC \n         LIMIT $2`,\n        [userId, limit]\n      );\n\n      return result.rows.map((row) => ({\n        ...row,\n        analysis_data: row.analysis_data ? JSON.parse(row.analysis_data) : null,\n      }));\n    } catch (error) {\n      logger.error({ message: 'Failed to get match history', error });\n      return [];\n    }\n  }\n}\n\nexport default new MatchAnalysisEngineService();\n
