/**\n * Coach Voice Service\n * Text-to-speech and voice reactions\n */\n\nimport { TextToSpeechClient } from '@google-cloud/text-to-speech';\nimport db from '../database/connection';\nimport logger from '../utils/logger';\n\ninterface VoiceConfig {\n  language: string;\n  gender: 'MALE' | 'FEMALE' | 'NEUTRAL';\n  pitch: number;\n  speakingRate: number;\n}\n\nclass CoachVoiceService {\n  private client: TextToSpeechClient;\n  private voiceConfigs: Map<string, VoiceConfig> = new Map();\n\n  constructor() {\n    this.client = new TextToSpeechClient({\n      keyFilename: process.env.GOOGLE_CLOUD_KEY_FILE,\n    });\n\n    // Initialize voice configs for different coach personalities\n    this.voiceConfigs.set('Blaze', {\n      language: 'sv-SE',\n      gender: 'MALE',\n      pitch: 0.5,\n      speakingRate: 1.1,\n    });\n\n    this.voiceConfigs.set('Sage', {\n      language: 'sv-SE',\n      gender: 'MALE',\n      pitch: -0.5,\n      speakingRate: 0.9,\n    });\n\n    this.voiceConfigs.set('Echo', {\n      language: 'sv-SE',\n      gender: 'FEMALE',\n      pitch: 0.2,\n      speakingRate: 1.0,\n    });\n\n    this.voiceConfigs.set('Nova', {\n      language: 'sv-SE',\n      gender: 'FEMALE',\n      pitch: 0.8,\n      speakingRate: 1.2,\n    });\n  }\n\n  /**\n   * Generate voice audio from text\n   */\n  async generateVoiceAudio(text: string, coachPersonality: string): Promise<Buffer | null> {\n    try {\n      const voiceConfig = this.voiceConfigs.get(coachPersonality);\n      if (!voiceConfig) {\n        logger.error(`Unknown coach personality: ${coachPersonality}`);\n        return null;\n      }\n\n      const request = {\n        input: { text },\n        voice: {\n          languageCode: voiceConfig.language,\n          ssmlGender: voiceConfig.gender,\n        },\n        audioConfig: {\n          audioEncoding: 'MP3',\n          pitch: voiceConfig.pitch,\n          speakingRate: voiceConfig.speakingRate,\n        },\n      };\n\n      const [response] = await this.client.synthesizeSpeech(request);\n      const audioContent = response.audioContent as Buffer;\n\n      return audioContent;\n    } catch (error) {\n      logger.error({ message: 'Failed to generate voice audio', error });\n      return null;\n    }\n  }\n\n  /**\n   * Generate coach reaction audio\n   */\n  async generateCoachReactionAudio(\n    userId: string,\n    eventType: string,\n    eventData: any\n  ): Promise<{ text: string; audio: Buffer } | null> {\n    try {\n      // Get user's coach personality\n      const result = await db.query(\n        'SELECT coach_personality FROM coach_personalities WHERE user_id = $1',\n        [userId]\n      );\n\n      if (result.rows.length === 0) {\n        return null;\n      }\n\n      const coachPersonality = result.rows[0].coach_personality;\n\n      // Generate reaction text based on event\n      const reactionText = this.generateReactionText(eventType, eventData, coachPersonality);\n\n      // Generate audio\n      const audio = await this.generateVoiceAudio(reactionText, coachPersonality);\n\n      if (!audio) {\n        return null;\n      }\n\n      return { text: reactionText, audio };\n    } catch (error) {\n      logger.error({ message: 'Failed to generate coach reaction audio', error });\n      return null;\n    }\n  }\n\n  /**\n   * Generate reaction text based on event\n   */\n  private generateReactionText(eventType: string, eventData: any, personality: string): string {\n    const reactions: { [key: string]: { [key: string]: string[] } } = {\n      Blaze: {\n        kill: [\n          'YOOO! Du är en legend!',\n          'Sjukt bra! Fortsätt så!',\n          'HAHA! Det var perfekt!',\n        ],\n        death: [\n          'Nej! Var mer försiktig nästa gång!',\n          'Det var en misstag. Fokusera!',\n          'Du kan göra bättre än så!',\n        ],\n        rankup: [\n          'YESSS! Du rankade upp! Grattis!',\n          'Du är en champion! Fortsätt så!',\n          'Sjukt bra progression!',\n        ],\n        achievement: [\n          'Du låste upp en achievement! Awesome!',\n          'Grattis på denna prestation!',\n          'Du är på väg till toppen!',\n        ],\n      },\n      Sage: {\n        kill: [\n          'Intressant taktik. Bra timing.',\n          'Din positioning var optimal.',\n          'En väl genomförd aktion.',\n        ],\n        death: [\n          'Analysera denna situation. Vad gick fel?',\n          'Din position var exponerad.',\n          'Nästa gång, var mer försiktig.',\n        ],\n        rankup: [\n          'Din progression följer en positiv kurva.',\n          'Du har visat konsistent förbättring.',\n          'Rankuppgången var väl förtjänad.',\n        ],\n        achievement: [\n          'Du har uppnått en betydelsefull milstolpe.',\n          'Din dedikation har lönat sig.',\n          'Denna prestation reflekterar dina förbättringar.',\n        ],\n      },\n      Echo: {\n        kill: [\n          'Bra gjort! Du är på rätt väg.',\n          'Fin kill! Fortsätt fokusera.',\n          'Du spelar bra idag!',\n        ],\n        death: [\n          'Det var tuff. Du klarar det nästa gång.',\n          'Inte ditt bästa moment, men du kan göra bättre.',\n          'Fokusera och kom tillbaka starkare.',\n        ],\n        rankup: [\n          'Grattis på rankuppgången! Du förtjänar det.',\n          'Du har gjort en bra resa. Fortsätt!',\n          'Du är på väg uppåt. Bra jobbat!',\n        ],\n        achievement: [\n          'Du låste upp något speciellt!',\n          'Grattis på denna achievement!',\n          'Du växer varje dag!',\n        ],\n      },\n      Nova: {\n        kill: [\n          'Haha! Du är insane! Bra kill!',\n          'Dude! Det var sick! Fortsätt!',\n          'Yo! Du är en monster!',\n        ],\n        death: [\n          'Haha, no worries! Du får dem nästa gång!',\n          'Dude, det händer. Shake it off!',\n          'Yo, du klarar det! Fokusera!',\n        ],\n        rankup: [\n          'Haha! Du rankade upp! Grattis grabben!',\n          'Dude! Du är en legend nu!',\n          'Yo! Du är på väg till toppen!',\n        ],\n        achievement: [\n          'Haha! Du är insane! Achievement unlocked!',\n          'Dude! Du är en champion!',\n          'Yo! Du är amazing!',\n        ],\n      },\n    };\n\n    const personalityReactions = reactions[personality] || reactions['Blaze'];\n    const eventReactions = personalityReactions[eventType] || ['Bra gjort!'];\n\n    return eventReactions[Math.floor(Math.random() * eventReactions.length)];\n  }\n\n  /**\n   * Cache voice audio\n   */\n  async cacheVoiceAudio(\n    userId: string,\n    text: string,\n    coachPersonality: string,\n    audio: Buffer\n  ): Promise<boolean> {\n    try {\n      const hash = require('crypto')\n        .createHash('md5')\n        .update(text + coachPersonality)\n        .digest('hex');\n\n      await db.query(\n        `INSERT INTO voice_cache (user_id, text_hash, coach_personality, audio_data)\n         VALUES ($1, $2, $3, $4)\n         ON CONFLICT (text_hash, coach_personality) DO NOTHING`,\n        [userId, hash, coachPersonality, audio]\n      );\n\n      return true;\n    } catch (error) {\n      logger.error({ message: 'Failed to cache voice audio', error });\n      return false;\n    }\n  }\n\n  /**\n   * Get cached voice audio\n   */\n  async getCachedVoiceAudio(text: string, coachPersonality: string): Promise<Buffer | null> {\n    try {\n      const hash = require('crypto')\n        .createHash('md5')\n        .update(text + coachPersonality)\n        .digest('hex');\n\n      const result = await db.query(\n        'SELECT audio_data FROM voice_cache WHERE text_hash = $1 AND coach_personality = $2',\n        [hash, coachPersonality]\n      );\n\n      if (result.rows.length > 0) {\n        return result.rows[0].audio_data;\n      }\n\n      return null;\n    } catch (error) {\n      logger.error({ message: 'Failed to get cached voice audio', error });\n      return null;\n    }\n  }\n}\n\nexport default new CoachVoiceService();\n
