/**\n * Advanced Analytics Service\n * Detailed analytics and insights\n */\n\nimport db from '../database/connection.js';\nimport logger from '../utils/logger.js';\n\ninterface UserAnalytics {\n  userId: string;\n  totalMatches: number;\n  winRate: number;\n  averageKDA: { kills: number; deaths: number; assists: number };\n  mainRole: string;\n  mainChampion: string;\n  averageGameDuration: number;\n  averageCSPerMinute: number;\n  averageDamageDealt: number;\n  averageDamageTaken: number;\n  trends: {\n    winRateTrend: number;\n    kdaTrend: number;\n    csTrend: number;\n  };\n}\n\ninterface CohortAnalytics {\n  cohortName: string;\n  userCount: number;\n  retentionDay1: number;\n  retentionDay7: number;\n  retentionDay30: number;\n  averageSessionLength: number;\n  averageMatchesPerDay: number;\n}\n\nclass AdvancedAnalyticsService {\n  /**\n   * Get user analytics\n   */\n  async getUserAnalytics(userId: string): Promise<UserAnalytics | null> {\n    try {\n      // Get match data\n      const matchResult = await db.query(\n        `SELECT \n           COUNT(*) as total_matches,\n           SUM(CASE WHEN result = 'win' THEN 1 ELSE 0 END) as wins,\n           AVG(kills) as avg_kills,\n           AVG(deaths) as avg_deaths,\n           AVG(assists) as avg_assists,\n           AVG(duration) as avg_duration,\n           AVG(cs_per_minute) as avg_cs_per_minute,\n           AVG(damage_dealt) as avg_damage_dealt,\n           AVG(damage_taken) as avg_damage_taken\n         FROM matches\n         WHERE user_id = $1`,\n        [userId]\n      );\n\n      if (matchResult.rows.length === 0 || matchResult.rows[0].total_matches === 0) {\n        return null;\n      }\n\n      const matchData = matchResult.rows[0];\n      const winRate = (matchData.wins / matchData.total_matches) * 100;\n\n      // Get main role\n      const roleResult = await db.query(\n        `SELECT role, COUNT(*) as count\n         FROM matches\n         WHERE user_id = $1\n         GROUP BY role\n         ORDER BY count DESC\n         LIMIT 1`,\n        [userId]\n      );\n\n      // Get main champion\n      const championResult = await db.query(\n        `SELECT champion, COUNT(*) as count\n         FROM matches\n         WHERE user_id = $1\n         GROUP BY champion\n         ORDER BY count DESC\n         LIMIT 1`,\n        [userId]\n      );\n\n      // Calculate trends (last 7 days vs previous 7 days)\n      const trends = await this.calculateTrends(userId);\n\n      const analytics: UserAnalytics = {\n        userId,\n        totalMatches: matchData.total_matches,\n        winRate: Math.round(winRate * 100) / 100,\n        averageKDA: {\n          kills: Math.round(matchData.avg_kills * 100) / 100,\n          deaths: Math.round(matchData.avg_deaths * 100) / 100,\n          assists: Math.round(matchData.avg_assists * 100) / 100,\n        },\n        mainRole: roleResult.rows[0]?.role || 'Unknown',\n        mainChampion: championResult.rows[0]?.champion || 'Unknown',\n        averageGameDuration: Math.round(matchData.avg_duration),\n        averageCSPerMinute: Math.round(matchData.avg_cs_per_minute * 100) / 100,\n        averageDamageDealt: Math.round(matchData.avg_damage_dealt),\n        averageDamageTaken: Math.round(matchData.avg_damage_taken),\n        trends,\n      };\n\n      return analytics;\n    } catch (error) {\n      logger.error({ message: 'Failed to get user analytics', error });\n      return null;\n    }\n  }\n\n  /**\n   * Calculate trends\n   */\n  private async calculateTrends(userId: string): Promise<any> {\n    try {\n      // Last 7 days\n      const last7Result = await db.query(\n        `SELECT \n           SUM(CASE WHEN result = 'win' THEN 1 ELSE 0 END)::float / COUNT(*) as win_rate,\n           AVG((kills + assists) / NULLIF(deaths, 0)) as kda,\n           AVG(cs_per_minute) as cs_per_minute\n         FROM matches\n         WHERE user_id = $1 AND match_timestamp > NOW() - INTERVAL '7 days'`,\n        [userId]\n      );\n\n      // Previous 7 days\n      const prev7Result = await db.query(\n        `SELECT \n           SUM(CASE WHEN result = 'win' THEN 1 ELSE 0 END)::float / COUNT(*) as win_rate,\n           AVG((kills + assists) / NULLIF(deaths, 0)) as kda,\n           AVG(cs_per_minute) as cs_per_minute\n         FROM matches\n         WHERE user_id = $1 AND match_timestamp > NOW() - INTERVAL '14 days' AND match_timestamp <= NOW() - INTERVAL '7 days'`,\n        [userId]\n      );\n\n      const last7 = last7Result.rows[0];\n      const prev7 = prev7Result.rows[0];\n\n      return {\n        winRateTrend: ((last7.win_rate - prev7.win_rate) * 100) || 0,\n        kdaTrend: ((last7.kda - prev7.kda) / prev7.kda * 100) || 0,\n        csTrend: ((last7.cs_per_minute - prev7.cs_per_minute) / prev7.cs_per_minute * 100) || 0,\n      };\n    } catch (error) {\n      logger.error({ message: 'Failed to calculate trends', error });\n      return { winRateTrend: 0, kdaTrend: 0, csTrend: 0 };\n    }\n  }\n\n  /**\n   * Get cohort analytics\n   */\n  async getCohortAnalytics(cohortDays: number = 7): Promise<CohortAnalytics[]> {\n    try {\n      const result = await db.query(\n        `SELECT \n           DATE(created_at) as cohort_date,\n           COUNT(*) as user_count,\n           SUM(CASE WHEN last_login > created_at + INTERVAL '1 day' THEN 1 ELSE 0 END)::float / COUNT(*) as retention_day1,\n           SUM(CASE WHEN last_login > created_at + INTERVAL '7 days' THEN 1 ELSE 0 END)::float / COUNT(*) as retention_day7,\n           SUM(CASE WHEN last_login > created_at + INTERVAL '30 days' THEN 1 ELSE 0 END)::float / COUNT(*) as retention_day30\n         FROM users\n         WHERE created_at > NOW() - INTERVAL '90 days'\n         GROUP BY DATE(created_at)\n         ORDER BY cohort_date DESC`\n      );\n\n      return result.rows.map((row) => ({\n        cohortName: row.cohort_date,\n        userCount: row.user_count,\n        retentionDay1: Math.round(row.retention_day1 * 100),\n        retentionDay7: Math.round(row.retention_day7 * 100),\n        retentionDay30: Math.round(row.retention_day30 * 100),\n        averageSessionLength: 0,\n        averageMatchesPerDay: 0,\n      }));\n    } catch (error) {\n      logger.error({ message: 'Failed to get cohort analytics', error });\n      return [];\n    }\n  }\n\n  /**\n   * Get platform analytics\n   */\n  async getPlatformAnalytics() {\n    try {\n      const result = await db.query(\n        `SELECT \n           COUNT(*) as total_users,\n           COUNT(CASE WHEN last_login > NOW() - INTERVAL '1 day' THEN 1 END) as daily_active_users,\n           COUNT(CASE WHEN last_login > NOW() - INTERVAL '7 days' THEN 1 END) as weekly_active_users,\n           COUNT(CASE WHEN last_login > NOW() - INTERVAL '30 days' THEN 1 END) as monthly_active_users,\n           (SELECT COUNT(*) FROM matches) as total_matches,\n           (SELECT AVG(duration) FROM matches) as avg_match_duration,\n           (SELECT AVG(CASE WHEN result = 'win' THEN 1 ELSE 0 END) FROM matches) as global_win_rate\n         FROM users`\n      );\n\n      return result.rows[0];\n    } catch (error) {\n      logger.error({ message: 'Failed to get platform analytics', error });\n      return null;\n    }\n  }\n\n  /**\n   * Get churn prediction\n   */\n  async getChurnPrediction(): Promise<any[]> {\n    try {\n      const result = await db.query(\n        `SELECT \n           u.id,\n           u.username,\n           DATEDIFF(NOW(), u.last_login) as days_inactive,\n           COUNT(m.id) as matches_last_30_days,\n           CASE \n             WHEN DATEDIFF(NOW(), u.last_login) > 14 AND COUNT(m.id) < 5 THEN 'HIGH'\n             WHEN DATEDIFF(NOW(), u.last_login) > 7 AND COUNT(m.id) < 10 THEN 'MEDIUM'\n             ELSE 'LOW'\n           END as churn_risk\n         FROM users u\n         LEFT JOIN matches m ON u.id = m.user_id AND m.match_timestamp > NOW() - INTERVAL '30 days'\n         GROUP BY u.id, u.username, u.last_login\n         HAVING DATEDIFF(NOW(), u.last_login) > 3\n         ORDER BY churn_risk DESC, days_inactive DESC\n         LIMIT 100`\n      );\n\n      return result.rows;\n    } catch (error) {\n      logger.error({ message: 'Failed to get churn prediction', error });\n      return [];\n    }\n  }\n\n  /**\n   * Get feature usage analytics\n   */\n  async getFeatureUsageAnalytics() {\n    try {\n      const result = await db.query(\n        `SELECT \n           'CoachOS' as feature,\n           COUNT(DISTINCT user_id) as users_using,\n           COUNT(*) as total_interactions\n         FROM coach_interactions\n         UNION ALL\n         SELECT \n           'Achievements',\n           COUNT(DISTINCT user_id),\n           COUNT(*)\n         FROM achievements\n         UNION ALL\n         SELECT \n           'Social',\n           COUNT(DISTINCT user_id),\n           COUNT(*)\n         FROM friends\n         UNION ALL\n         SELECT \n           'Tournaments',\n           COUNT(DISTINCT user_id),\n           COUNT(*)\n         FROM tournament_participants`\n      );\n\n      return result.rows;\n    } catch (error) {\n      logger.error({ message: 'Failed to get feature usage analytics', error });\n      return [];\n    }\n  }\n}\n\nexport default new AdvancedAnalyticsService();\n
