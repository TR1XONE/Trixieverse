/**\n * Video Replay Analysis Service\n * Auto-analyze match replays\n */\n\nimport db from '../database/connection.js';\nimport logger from '../utils/logger.js';\nimport axios from 'axios';\n\ninterface ReplayAnalysis {\n  matchId: string;\n  videoUrl: string;\n  duration: number;\n  highlights: string[];\n  mistakes: string[];\n  improvements: string[];\n  overallScore: number;\n  timestamp: Date;\n}\n\nclass ReplayAnalysisService {\n  /**\n   * Upload replay video\n   */\n  async uploadReplayVideo(userId: string, matchId: string, videoFile: Buffer): Promise<string | null> {\n    try {\n      // Upload to cloud storage (e.g., AWS S3, Google Cloud Storage)\n      const videoUrl = await this.uploadToCloudStorage(videoFile, `replays/${userId}/${matchId}.mp4`);\n\n      if (!videoUrl) {\n        return null;\n      }\n\n      // Save to database\n      await db.query(\n        `INSERT INTO replay_videos (user_id, match_id, video_url)\n         VALUES ($1, $2, $3)`,\n        [userId, matchId, videoUrl]\n      );\n\n      logger.info(`Replay video uploaded: ${matchId}`);\n      return videoUrl;\n    } catch (error) {\n      logger.error({ message: 'Failed to upload replay video', error });\n      return null;\n    }\n  }\n\n  /**\n   * Analyze replay video\n   */\n  async analyzeReplayVideo(userId: string, matchId: string, videoUrl: string): Promise<ReplayAnalysis | null> {\n    try {\n      // Get match data\n      const matchResult = await db.query(\n        'SELECT * FROM matches WHERE user_id = $1 AND match_id = $2',\n        [userId, matchId]\n      );\n\n      if (matchResult.rows.length === 0) {\n        return null;\n      }\n\n      const matchData = matchResult.rows[0];\n\n      // Analyze video (simplified - in production, use ML model)\n      const highlights = this.extractHighlights(matchData);\n      const mistakes = this.extractMistakes(matchData);\n      const improvements = this.generateImprovements(matchData);\n      const overallScore = this.calculateOverallScore(matchData);\n\n      const analysis: ReplayAnalysis = {\n        matchId,\n        videoUrl,\n        duration: matchData.duration,\n        highlights,\n        mistakes,\n        improvements,\n        overallScore,\n        timestamp: new Date(),\n      };\n\n      // Save analysis\n      await db.query(\n        `INSERT INTO replay_analyses (user_id, match_id, analysis_data)\n         VALUES ($1, $2, $3)`,\n        [userId, matchId, JSON.stringify(analysis)]\n      );\n\n      logger.info(`Replay analyzed: ${matchId}`);\n      return analysis;\n    } catch (error) {\n      logger.error({ message: 'Failed to analyze replay video', error });\n      return null;\n    }\n  }\n\n  /**\n   * Extract highlights from match data\n   */\n  private extractHighlights(matchData: any): string[] {\n    const highlights: string[] = [];\n\n    // Multi-kill\n    if (matchData.kills >= 10) {\n      highlights.push(`üî• High kill count: ${matchData.kills} kills`);\n    }\n\n    // Perfect KDA\n    if (matchData.deaths === 0 && matchData.kills > 0) {\n      highlights.push('üõ°Ô∏è Perfect KDA - no deaths!');\n    }\n\n    // High damage\n    if (matchData.damage_dealt > matchData.damage_taken * 2) {\n      highlights.push(`‚öîÔ∏è High damage output: ${matchData.damage_dealt} damage`);\n    }\n\n    // Great CS\n    if (matchData.cs_per_minute >= 8) {\n      highlights.push(`üí∞ Excellent CS: ${matchData.cs_per_minute.toFixed(1)} CS/min`);\n    }\n\n    // Clutch play\n    if (matchData.result === 'win' && matchData.kills >= 5) {\n      highlights.push('üéØ Clutch victory - great teamfighting!');\n    }\n\n    return highlights.length > 0 ? highlights : ['‚ú® Good effort'];\n  }\n\n  /**\n   * Extract mistakes from match data\n   */\n  private extractMistakes(matchData: any): string[] {\n    const mistakes: string[] = [];\n\n    // Too many deaths\n    if (matchData.deaths >= 5) {\n      mistakes.push(`‚ùå Too many deaths: ${matchData.deaths} deaths - work on positioning`);\n    }\n\n    // Low CS\n    if (matchData.cs_per_minute < 4) {\n      mistakes.push(`‚ùå Low CS: ${matchData.cs_per_minute.toFixed(1)} CS/min - focus on last-hitting`);\n    }\n\n    // Low damage\n    if (matchData.damage_dealt < matchData.damage_taken) {\n      mistakes.push('‚ùå Low damage output - be more aggressive in fights');\n    }\n\n    // Low KDA\n    const kda = (matchData.kills + matchData.assists) / Math.max(matchData.deaths, 1);\n    if (kda < 1) {\n      mistakes.push(`‚ùå Low KDA: ${kda.toFixed(2)} - improve your impact`);\n    }\n\n    // Lost game\n    if (matchData.result === 'loss') {\n      mistakes.push('‚ùå Lost the game - analyze what went wrong');\n    }\n\n    return mistakes.length > 0 ? mistakes : ['‚úÖ No major mistakes'];\n  }\n\n  /**\n   * Generate improvements\n   */\n  private generateImprovements(matchData: any): string[] {\n    const improvements: string[] = [];\n\n    // Positioning\n    if (matchData.deaths >= 3) {\n      improvements.push('üìç Improve positioning - stay safer in fights');\n    }\n\n    // CS\n    if (matchData.cs_per_minute < 6) {\n      improvements.push('üéØ Improve CS - aim for 6+ CS per minute');\n    }\n\n    // Map awareness\n    if (matchData.deaths >= 4) {\n      improvements.push('üó∫Ô∏è Improve map awareness - check minimap frequently');\n    }\n\n    // Teamfighting\n    if (matchData.damage_dealt < matchData.damage_taken) {\n      improvements.push('‚öîÔ∏è Improve teamfighting - position better in fights');\n    }\n\n    // Macro play\n    if (matchData.result === 'loss') {\n      improvements.push('üéÆ Improve macro play - better objective control');\n    }\n\n    return improvements.length > 0 ? improvements : ['‚úÖ Keep improving!'];\n  }\n\n  /**\n   * Calculate overall score\n   */\n  private calculateOverallScore(matchData: any): number {\n    let score = 50; // Base score\n\n    // KDA bonus\n    const kda = (matchData.kills + matchData.assists) / Math.max(matchData.deaths, 1);\n    score += Math.min(kda * 5, 20);\n\n    // CS bonus\n    score += Math.min(matchData.cs_per_minute, 20);\n\n    // Damage bonus\n    const damageRatio = matchData.damage_dealt / Math.max(matchData.damage_taken, 1);\n    score += Math.min(damageRatio * 5, 15);\n\n    // Result bonus\n    if (matchData.result === 'win') {\n      score += 15;\n    }\n\n    return Math.min(score, 100);\n  }\n\n  /**\n   * Get replay analysis\n   */\n  async getReplayAnalysis(userId: string, matchId: string): Promise<ReplayAnalysis | null> {\n    try {\n      const result = await db.query(\n        'SELECT analysis_data FROM replay_analyses WHERE user_id = $1 AND match_id = $2',\n        [userId, matchId]\n      );\n\n      if (result.rows.length === 0) {\n        return null;\n      }\n\n      return result.rows[0].analysis_data;\n    } catch (error) {\n      logger.error({ message: 'Failed to get replay analysis', error });\n      return null;\n    }\n  }\n\n  /**\n   * Get recent replay analyses\n   */\n  async getRecentReplayAnalyses(userId: string, limit: number = 10): Promise<ReplayAnalysis[]> {\n    try {\n      const result = await db.query(\n        `SELECT analysis_data FROM replay_analyses \n         WHERE user_id = $1 \n         ORDER BY created_at DESC \n         LIMIT $2`,\n        [userId, limit]\n      );\n\n      return result.rows.map((row) => row.analysis_data);\n    } catch (error) {\n      logger.error({ message: 'Failed to get recent replay analyses', error });\n      return [];\n    }\n  }\n\n  /**\n   * Upload to cloud storage (placeholder)\n   */\n  private async uploadToCloudStorage(file: Buffer, path: string): Promise<string | null> {\n    try {\n      // In production, implement actual cloud storage upload\n      // For now, return a placeholder URL\n      const url = `https://replays.trixieverse.com/${path}`;\n      logger.info(`File uploaded to cloud storage: ${url}`);\n      return url;\n    } catch (error) {\n      logger.error({ message: 'Failed to upload to cloud storage', error });\n      return null;\n    }\n  }\n}\n\nexport default new ReplayAnalysisService();\n
