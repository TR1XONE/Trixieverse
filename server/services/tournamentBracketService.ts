/**\n * Tournament Bracket Service\n * Tournament management and bracket generation\n */\n\nimport db from '../database/connection.js';\nimport logger from '../utils/logger.js';\n\ninterface Tournament {\n  id: string;\n  name: string;\n  format: 'single_elimination' | 'double_elimination' | 'round_robin';\n  maxParticipants: number;\n  participants: string[];\n  status: 'pending' | 'in_progress' | 'completed';\n  createdAt: Date;\n  startDate: Date;\n}\n\ninterface Match {\n  id: string;\n  tournamentId: string;\n  player1Id: string;\n  player2Id: string;\n  winner?: string;\n  score?: string;\n  status: 'pending' | 'in_progress' | 'completed';\n  scheduledTime: Date;\n}\n\nclass TournamentBracketService {\n  /**\n   * Create tournament\n   */\n  async createTournament(\n    name: string,\n    format: string,\n    maxParticipants: number,\n    startDate: Date\n  ): Promise<Tournament | null> {\n    try {\n      const id = require('crypto').randomBytes(8).toString('hex');\n\n      const result = await db.query(\n        `INSERT INTO tournaments (id, name, format, max_participants, status, start_date)\n         VALUES ($1, $2, $3, $4, $5, $6)\n         RETURNING *`,\n        [id, name, format, maxParticipants, 'pending', startDate]\n      );\n\n      logger.info(`Tournament created: ${id}`);\n\n      return {\n        id: result.rows[0].id,\n        name: result.rows[0].name,\n        format: result.rows[0].format,\n        maxParticipants: result.rows[0].max_participants,\n        participants: [],\n        status: result.rows[0].status,\n        createdAt: result.rows[0].created_at,\n        startDate: result.rows[0].start_date,\n      };\n    } catch (error) {\n      logger.error({ message: 'Failed to create tournament', error });\n      return null;\n    }\n  }\n\n  /**\n   * Register participant\n   */\n  async registerParticipant(tournamentId: string, userId: string): Promise<boolean> {\n    try {\n      // Check tournament status\n      const tournament = await db.query('SELECT * FROM tournaments WHERE id = $1', [tournamentId]);\n\n      if (tournament.rows.length === 0) {\n        return false;\n      }\n\n      if (tournament.rows[0].status !== 'pending') {\n        return false; // Tournament already started\n      }\n\n      // Check participant count\n      const participants = await db.query(\n        'SELECT COUNT(*) FROM tournament_participants WHERE tournament_id = $1',\n        [tournamentId]\n      );\n\n      if (participants.rows[0].count >= tournament.rows[0].max_participants) {\n        return false; // Tournament is full\n      }\n\n      // Register participant\n      await db.query(\n        `INSERT INTO tournament_participants (tournament_id, user_id)\n         VALUES ($1, $2)`,\n        [tournamentId, userId]\n      );\n\n      logger.info(`Participant registered: ${userId} in tournament ${tournamentId}`);\n      return true;\n    } catch (error) {\n      logger.error({ message: 'Failed to register participant', error });\n      return false;\n    }\n  }\n\n  /**\n   * Generate bracket\n   */\n  async generateBracket(tournamentId: string): Promise<Match[] | null> {\n    try {\n      // Get tournament\n      const tournament = await db.query('SELECT * FROM tournaments WHERE id = $1', [tournamentId]);\n\n      if (tournament.rows.length === 0) {\n        return null;\n      }\n\n      // Get participants\n      const participants = await db.query(\n        `SELECT user_id FROM tournament_participants WHERE tournament_id = $1\n         ORDER BY RANDOM()`,\n        [tournamentId]\n      );\n\n      if (participants.rows.length === 0) {\n        return null;\n      }\n\n      const userIds = participants.rows.map((row) => row.user_id);\n\n      // Generate matches based on format\n      const matches: Match[] = [];\n\n      if (tournament.rows[0].format === 'single_elimination') {\n        matches.push(...this.generateSingleEliminationMatches(tournamentId, userIds));\n      } else if (tournament.rows[0].format === 'double_elimination') {\n        matches.push(...this.generateDoubleEliminationMatches(tournamentId, userIds));\n      } else if (tournament.rows[0].format === 'round_robin') {\n        matches.push(...this.generateRoundRobinMatches(tournamentId, userIds));\n      }\n\n      // Save matches\n      for (const match of matches) {\n        await db.query(\n          `INSERT INTO tournament_matches (id, tournament_id, player1_id, player2_id, status, scheduled_time)\n           VALUES ($1, $2, $3, $4, $5, $6)`,\n          [match.id, match.tournamentId, match.player1Id, match.player2Id, match.status, match.scheduledTime]\n        );\n      }\n\n      // Update tournament status\n      await db.query('UPDATE tournaments SET status = $1 WHERE id = $2', ['in_progress', tournamentId]);\n\n      logger.info(`Bracket generated for tournament: ${tournamentId}`);\n      return matches;\n    } catch (error) {\n      logger.error({ message: 'Failed to generate bracket', error });\n      return null;\n    }\n  }\n\n  /**\n   * Generate single elimination matches\n   */\n  private generateSingleEliminationMatches(tournamentId: string, userIds: string[]): Match[] {\n    const matches: Match[] = [];\n    let round = 1;\n\n    for (let i = 0; i < userIds.length; i += 2) {\n      if (i + 1 < userIds.length) {\n        const matchId = require('crypto').randomBytes(8).toString('hex');\n        const scheduledTime = new Date(Date.now() + round * 24 * 60 * 60 * 1000);\n\n        matches.push({\n          id: matchId,\n          tournamentId,\n          player1Id: userIds[i],\n          player2Id: userIds[i + 1],\n          status: 'pending',\n          scheduledTime,\n        });\n      }\n    }\n\n    return matches;\n  }\n\n  /**\n   * Generate double elimination matches\n   */\n  private generateDoubleEliminationMatches(tournamentId: string, userIds: string[]): Match[] {\n    // First round matches\n    const matches = this.generateSingleEliminationMatches(tournamentId, userIds);\n\n    // Loser bracket matches (simplified)\n    for (let i = 0; i < Math.floor(userIds.length / 2); i += 2) {\n      if (i + 1 < Math.floor(userIds.length / 2)) {\n        const matchId = require('crypto').randomBytes(8).toString('hex');\n        const scheduledTime = new Date(Date.now() + 2 * 24 * 60 * 60 * 1000);\n\n        matches.push({\n          id: matchId,\n          tournamentId,\n          player1Id: `loser_${i}`,\n          player2Id: `loser_${i + 1}`,\n          status: 'pending',\n          scheduledTime,\n        });\n      }\n    }\n\n    return matches;\n  }\n\n  /**\n   * Generate round robin matches\n   */\n  private generateRoundRobinMatches(tournamentId: string, userIds: string[]): Match[] {\n    const matches: Match[] = [];\n    let round = 1;\n\n    for (let i = 0; i < userIds.length; i++) {\n      for (let j = i + 1; j < userIds.length; j++) {\n        const matchId = require('crypto').randomBytes(8).toString('hex');\n        const scheduledTime = new Date(Date.now() + round * 24 * 60 * 60 * 1000);\n\n        matches.push({\n          id: matchId,\n          tournamentId,\n          player1Id: userIds[i],\n          player2Id: userIds[j],\n          status: 'pending',\n          scheduledTime,\n        });\n\n        round++;\n      }\n    }\n\n    return matches;\n  }\n\n  /**\n   * Report match result\n   */\n  async reportMatchResult(\n    matchId: string,\n    winnerId: string,\n    score: string\n  ): Promise<boolean> {\n    try {\n      await db.query(\n        `UPDATE tournament_matches SET winner_id = $1, score = $2, status = $3\n         WHERE id = $4`,\n        [winnerId, score, 'completed', matchId]\n      );\n\n      logger.info(`Match result reported: ${matchId}`);\n      return true;\n    } catch (error) {\n      logger.error({ message: 'Failed to report match result', error });\n      return false;\n    }\n  }\n\n  /**\n   * Get tournament standings\n   */\n  async getTournamentStandings(tournamentId: string): Promise<any[]> {\n    try {\n      const result = await db.query(\n        `SELECT \n           u.username,\n           COUNT(CASE WHEN tm.winner_id = tp.user_id THEN 1 END) as wins,\n           COUNT(tm.id) - COUNT(CASE WHEN tm.winner_id = tp.user_id THEN 1 END) as losses\n         FROM tournament_participants tp\n         JOIN users u ON tp.user_id = u.id\n         LEFT JOIN tournament_matches tm ON (tp.user_id = tm.player1_id OR tp.user_id = tm.player2_id) AND tm.tournament_id = $1\n         WHERE tp.tournament_id = $1\n         GROUP BY u.username, tp.user_id\n         ORDER BY wins DESC, losses ASC`,\n        [tournamentId]\n      );\n\n      return result.rows;\n    } catch (error) {\n      logger.error({ message: 'Failed to get tournament standings', error });\n      return [];\n    }\n  }\n\n  /**\n   * Complete tournament\n   */\n  async completeTournament(tournamentId: string): Promise<boolean> {\n    try {\n      await db.query('UPDATE tournaments SET status = $1 WHERE id = $2', ['completed', tournamentId]);\n\n      logger.info(`Tournament completed: ${tournamentId}`);\n      return true;\n    } catch (error) {\n      logger.error({ message: 'Failed to complete tournament', error });\n      return false;\n    }\n  }\n}\n\nexport default new TournamentBracketService();\n
