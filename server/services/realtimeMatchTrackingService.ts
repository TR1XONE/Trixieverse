/**\n * Real-time Match Tracking Service\n * Live match updates and in-game coaching\n */\n\nimport { Server as SocketIOServer, Socket } from 'socket.io';\nimport db from '../database/connection';\nimport logger from '../utils/logger';\nimport riotApiService from './riotApiIntegrationService.js';\nimport coachLearningService from './coachLearningService.js';\n\ninterface LiveMatch {\n  matchId: string;\n  userId: string;\n  startTime: Date;\n  currentTime: number;\n  participants: any[];\n  gameState: 'loading' | 'in_progress' | 'ended';\n  playerStats: {\n    kills: number;\n    deaths: number;\n    assists: number;\n    cs: number;\n    gold: number;\n    damageDealt: number;\n    damageTaken: number;\n  };\n}\n\nclass RealtimeMatchTrackingService {\n  private io: SocketIOServer | null = null;\n  private activeSessions: Map<string, LiveMatch> = new Map();\n  private userSockets: Map<string, Socket> = new Map();\n\n  /**\n   * Initialize Socket.IO\n   */\n  initializeSocketIO(io: SocketIOServer) {\n    this.io = io;\n\n    io.on('connection', (socket: Socket) => {\n      logger.info(`User connected: ${socket.id}`);\n\n      socket.on('start_match_tracking', (data) => this.handleStartTracking(socket, data));\n      socket.on('match_update', (data) => this.handleMatchUpdate(socket, data));\n      socket.on('end_match_tracking', (data) => this.handleEndTracking(socket, data));\n      socket.on('disconnect', () => this.handleDisconnect(socket));\n    });\n  }\n\n  /**\n   * Handle start match tracking\n   */\n  private async handleStartTracking(socket: Socket, data: any) {\n    try {\n      const { userId, matchId } = data;\n\n      const liveMatch: LiveMatch = {\n        matchId,\n        userId,\n        startTime: new Date(),\n        currentTime: 0,\n        participants: [],\n        gameState: 'loading',\n        playerStats: {\n          kills: 0,\n          deaths: 0,\n          assists: 0,\n          cs: 0,\n          gold: 0,\n          damageDealt: 0,\n          damageTaken: 0,\n        },\n      };\n\n      this.activeSessions.set(matchId, liveMatch);\n      this.userSockets.set(userId, socket);\n\n      // Store in database\n      await db.query(\n        `INSERT INTO live_matches (match_id, user_id, start_time, game_state)\n         VALUES ($1, $2, $3, $4)`,\n        [matchId, userId, new Date(), 'loading']\n      );\n\n      socket.emit('tracking_started', { matchId });\n      logger.info(`Match tracking started: ${matchId}`);\n    } catch (error) {\n      logger.error({ message: 'Failed to start match tracking', error });\n      socket.emit('error', { message: 'Failed to start tracking' });\n    }\n  }\n\n  /**\n   * Handle match update\n   */\n  private async handleMatchUpdate(socket: Socket, data: any) {\n    try {\n      const { matchId, stats, gameState, timestamp } = data;\n      const liveMatch = this.activeSessions.get(matchId);\n\n      if (!liveMatch) {\n        socket.emit('error', { message: 'Match not found' });\n        return;\n      }\n\n      // Update match state\n      liveMatch.gameState = gameState;\n      liveMatch.currentTime = timestamp;\n      liveMatch.playerStats = stats;\n\n      // Update database\n      await db.query(\n        `UPDATE live_matches SET \n           current_time = $1,\n           game_state = $2,\n           player_stats = $3,\n           updated_at = CURRENT_TIMESTAMP\n         WHERE match_id = $4`,\n        [timestamp, gameState, JSON.stringify(stats), matchId]\n      );\n\n      // Generate coach insights based on current stats\n      const coachInsight = await this.generateCoachInsight(liveMatch);\n\n      // Broadcast to connected clients\n      socket.emit('match_updated', {\n        matchId,\n        stats,\n        gameState,\n        coachInsight,\n      });\n\n      logger.info(`Match updated: ${matchId}`);\n    } catch (error) {\n      logger.error({ message: 'Failed to update match', error });\n      socket.emit('error', { message: 'Failed to update match' });\n    }\n  }\n\n  /**\n   * Handle end match tracking\n   */\n  private async handleEndTracking(socket: Socket, data: any) {\n    try {\n      const { matchId, result, finalStats } = data;\n      const liveMatch = this.activeSessions.get(matchId);\n\n      if (!liveMatch) {\n        socket.emit('error', { message: 'Match not found' });\n        return;\n      }\n\n      // Update database\n      await db.query(\n        `UPDATE live_matches SET \n           game_state = 'ended',\n           result = $1,\n           final_stats = $2,\n           ended_at = CURRENT_TIMESTAMP\n         WHERE match_id = $3`,\n        [result, JSON.stringify(finalStats), matchId]\n      );\n\n      // Save match analysis\n      const analysis = await this.generateMatchAnalysis(liveMatch, finalStats);\n\n      // Update coach learning\n      await coachLearningService.updateCoachMemory(liveMatch.userId, {\n        matchId,\n        result,\n        stats: finalStats,\n        analysis,\n      });\n\n      // Remove from active sessions\n      this.activeSessions.delete(matchId);\n      this.userSockets.delete(liveMatch.userId);\n\n      socket.emit('tracking_ended', { matchId, analysis });\n      logger.info(`Match tracking ended: ${matchId}`);\n    } catch (error) {\n      logger.error({ message: 'Failed to end match tracking', error });\n      socket.emit('error', { message: 'Failed to end tracking' });\n    }\n  }\n\n  /**\n   * Handle disconnect\n   */\n  private handleDisconnect(socket: Socket) {\n    logger.info(`User disconnected: ${socket.id}`);\n\n    // Find and remove user from tracking\n    for (const [userId, userSocket] of this.userSockets.entries()) {\n      if (userSocket.id === socket.id) {\n        this.userSockets.delete(userId);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Generate coach insight based on current stats\n   */\n  private async generateCoachInsight(liveMatch: LiveMatch): Promise<string> {\n    const { playerStats, currentTime } = liveMatch;\n    const minutesElapsed = Math.floor(currentTime / 60);\n\n    // KDA analysis\n    if (playerStats.deaths > 3 && minutesElapsed < 10) {\n      return '‚ö†Ô∏è Watch your positioning! You have too many deaths early game.';\n    }\n\n    // CS analysis\n    const expectedCS = minutesElapsed * 5; // ~5 CS per minute\n    if (playerStats.cs < expectedCS * 0.8) {\n      return 'üí∞ Focus on farming! Your CS is behind schedule.';\n    }\n\n    // Damage analysis\n    if (playerStats.damageDealt < playerStats.damageTaken && minutesElapsed > 15) {\n      return '‚öîÔ∏è Be more aggressive! You\\'re taking more damage than dealing.';\n    }\n\n    // Gold analysis\n    const expectedGold = minutesElapsed * 200; // ~200 gold per minute\n    if (playerStats.gold > expectedGold * 1.2) {\n      return 'üèÜ Excellent farming! Keep it up!';\n    }\n\n    return 'üëç You\\'re doing well! Keep focusing on the game.';\n  }\n\n  /**\n   * Generate match analysis\n   */\n  private async generateMatchAnalysis(liveMatch: LiveMatch, finalStats: any): Promise<any> {\n    const { playerStats } = liveMatch;\n\n    return {\n      kda: `${finalStats.kills}/${finalStats.deaths}/${finalStats.assists}`,\n      cs: finalStats.cs,\n      csPerMinute: (finalStats.cs / (finalStats.duration / 60)).toFixed(1),\n      gold: finalStats.gold,\n      damageDealt: finalStats.damageDealt,\n      damageTaken: finalStats.damageTaken,\n      highlights: this.generateHighlights(finalStats),\n      improvements: this.generateImprovements(finalStats),\n    };\n  }\n\n  /**\n   * Generate highlights\n   */\n  private generateHighlights(stats: any): string[] {\n    const highlights: string[] = [];\n\n    if (stats.kills >= 10) highlights.push('üî• High kill count');\n    if (stats.deaths <= 2) highlights.push('üõ°Ô∏è Excellent survivability');\n    if (stats.cs / (stats.duration / 60) >= 8) highlights.push('üí∞ Great CS');\n    if (stats.damageDealt > stats.damageTaken * 1.5) highlights.push('‚öîÔ∏è High damage output');\n\n    return highlights.length > 0 ? highlights : ['‚ú® Good effort'];\n  }\n\n  /**\n   * Generate improvements\n   */\n  private generateImprovements(stats: any): string[] {\n    const improvements: string[] = [];\n\n    if (stats.deaths >= 5) improvements.push('üìâ Reduce deaths - focus on positioning');\n    if (stats.cs / (stats.duration / 60) < 5) improvements.push('üéØ Improve CS - last-hit more minions');\n    if (stats.damageDealt < stats.damageTaken) improvements.push('üí™ Increase damage - be more aggressive');\n\n    return improvements.length > 0 ? improvements : ['üëç Keep improving'];\n  }\n\n  /**\n   * Get active matches\n   */\n  getActiveMatches(): LiveMatch[] {\n    return Array.from(this.activeSessions.values());\n  }\n\n  /**\n   * Get user's active match\n   */\n  getUserActiveMatch(userId: string): LiveMatch | null {\n    for (const match of this.activeSessions.values()) {\n      if (match.userId === userId) {\n        return match;\n      }\n    }\n    return null;\n  }\n}\n\nexport default new RealtimeMatchTrackingService();\n
